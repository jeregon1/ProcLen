//*****************************************************************
// File:   alike.jj
// Author: Jes칰s L칩pez Ans칩n, 839922
// 		   Javier Sin Pelayo, 843442
// Date:   abril 2024
// Coms:   compilar mediante "ant"
// Doc:    https://javacc.github.io/javacc/
//*****************************************************************

options {
	IGNORE_CASE = true;
	UNICODE_INPUT = true;
	DEBUG_PARSER = false;
}

PARSER_BEGIN(alike_4)

package traductor;

import java.io.FileWriter;
import java.io.File;
import java.io.IOException;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.SemanticFunctions.SemanticFunctions;
import lib.attributes.*;

import lib.tools.codeGeneration.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;

public class alike_4 {

	static SemanticFunctions semantic; // Funciones sem치nticas

	static boolean verbose = false; // Flag modo verbose (impresi칩n bloque cerrado tabla de s칤mbolos)

   	public static void main(String[] args) {
	   	alike_4 parser = null;
		
		// argumento verbose
		if (args.length > 1 && args[1].equals("-v")) {
			verbose = true;
		}

		// creaci칩n de SemanticFuncions, donde se encapsula la l칩gica sem치ntica junto a la tabla de s칤mbolos
	   	semantic = new SemanticFunctions();
		String fileName = "";
	   
	   	try {
			if(args.length == 0) { // Si no se especifica fichero, se lee de la entrada est치ndar
				parser = new alike_4(System.in);
			}
			else {
				fileName = args[0];
				parser = new alike_4(new java.io.FileInputStream(fileName));
			}
			//Programa es el s칤mbolo inicial de la gram치tica
			parser.Programa(fileName);
			
			if (!semantic.hayErrores()) {
				fileName = fileName.substring(0, fileName.lastIndexOf('.')); // Eliminar extensi칩n
				System.out.println("Compilaci칩n finalizada. Se ha generado el fichero " + fileName + ".pcode");
			}
			else
				if (semantic.getNumErrores() == 1) {
					System.out.println("Detectado 1 error sem치ntico. No se genera c칩digo.");
				} else {
					System.out.println("Detectados " + semantic.getNumErrores() + " errores sem치nticos. No se genera c칩digo.");
				}
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + fileName + ".al" +" no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("ERROR L칄XICO: " + e.getMessage());
		}
		catch (ParseException e) {
			System.err.println("----------------------------------------");
			System.err.println(e.getMessage());
		}
		catch (Exception e) {
			e.printStackTrace();
		}
   }
}


PARSER_END(alike_4)

//---------------------------------------------------------


SKIP : {
	" " | "\t" | "\n" | "\r" 
	|  <COMMENT: "--" (~["\n", "\r"])*> 
}

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) > 
|	< #DIGIT: ["0"-"9"] >

	// Separadores
|	< tSEMICOLON: ";" >
|	< tCOLON: ":" >
|	< tCOMMA: "," >

	// Delimitadores
|	< tLPAREN: "(" >
|	< tRPAREN: ")" >

	// Tipos de datos
|	< tINT: "integer" >
|	< tCHAR: "character" >
|	< tBOOL: "boolean" >

|   < tARRAY: "array" >
| 	< tOF: "of" >
|	< tRANGE: ".." >

	// Palabras reservadas
|	< tWHILE: "while" > 
|   < tLOOP: "loop" >
|	< tIF: "if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >

|   < tPROCEDURE: "procedure" >
|   < tFUNCTION: "function" >
|   < tREF: "ref" >
|   < tIS: "is" >
|   < tBEGIN: "begin" >
|   < tEND: "end" >
|	< tRETURN: "return" > 

	// Funciones est치ndar
| 	< tPUT: "put" >
| 	< tPUT_LINE: "put_line" >
|	< tGET: "get" >
|	< tSKIP_LINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tEXIT: "exit" >
|	< tNULL: "null" >

	// Literales
| 	< tTRUE: "true" >
| 	< tFALSE: "false" >
| 	< tCONST_INT: (<DIGIT>)+ >
|	< tCONST_CHAR: "'"~[]"'" >
|	< tCONST_STRING: "\"" ((~["\""] | "\"\""))* "\"" > // Dos comillas dobles seguidas se consideran una comilla doble
	{
		// Sustituir las comillas dobles por una comilla simple
		String str = matchedToken.image;
		str = str.substring(1, str.length() - 1); // Eliminar las comillas dobles de los extremos
		matchedToken.image = str.replace("\"\"", "\""); // Sustituir las parejas de comillas dobles por una sola ocurrencia
	}

	// Operadores
|	< tASSIGN: ":=" > 
|	< tAND: "and" >
|	< tOR: "or" >
|	< tNOT: "not" >
|	< tEQ: "=" >
|	< tNEQ: "/=" >
|	< tLT: "<" >
|	< tLE: "<=" >
|	< tGT: ">" >
|	< tGE: ">=" >
|	< tPLUS: "+" >
|	< tMINUS: "-" >
|	< tMULT: "*" >
|	< tDIV: "/" >
|	< tMOD: "mod" >

	// Otros
|	< tID: (<LETTER> | "_") (<LETTER> | <DIGIT> | "_")* >

}

SPECIAL_TOKEN : { // Debe estar al final para que sea lo 칰ltimo en comprobarse
 	< tBASURA: ~[] >
	 	{
			System.err.println("----------------------------------------");
			System.err.println(TokenMgrError.LexicalErr(matchedToken, "Car치cter extra침o: '" + matchedToken.image + "'. Reemplazo por espacio"));
			matchedToken.image = " ";
	 	}
}

//------------ S칤mbolo inicial de la gram치tica.
// Programa: <tPROCEDURE> <tID> <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instruccion+ <tEND> <tSEMICOLON> <EOF>
void Programa(String file) :
{
	Token id;
	CodeBlock programa;
	Attributes at = new Attributes();
	String label;
}
{
	{ // Inicializaci칩n del programa
		label = CGUtils.newLabel();
		programa = new CodeBlock();
		programa.addInst(PCodeInstruction.OpCode.ENP, label); // Enter Program en 'label', definido justo arriba
		programa.addLabel(label);
	}
	<tPROCEDURE>
	id = <tID>
	{	// Procedimiento principal
		semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>()), label);
		semantic.setMainProcedureName(id.image);
	}
	<tIS>
		( declaracion_var(at) )*
		( declaracion_procedimiento(at) | declaracion_funcion(at) )*
	<tBEGIN>
		(instruccion(at))+
	<tEND> <tSEMICOLON>
	{
		if (verbose) semantic.printSymbolTable(id.image); // Impresi칩n de la tabla de s칤mbolos
		programa.addBlock(at.code);
		programa.addInst(PCodeInstruction.OpCode.LVP); // Leave Program
		if (!semantic.hayErrores()) {
			file = file.substring(0, file.lastIndexOf('.')); // Eliminar extensi칩n
			File f = new File(file + ".pcode");
			System.out.println("Generando fichero " + file + ".pcode");
			try {
				FileWriter fw = new FileWriter(f);
				fw.write(programa.toString());
				fw.close();
			}
			catch (IOException e) {
				System.err.println("Error al abrir el fichero");
			}
		}
	}
}

//declaracion_var: lista_ids <tCOLON> tipo_variable <tSEMICOLON>
void declaracion_var(Attributes at) :
{
	TypeAttrib typeAt = new TypeAttrib();
}
{
	lista_ids(typeAt)
	<tCOLON>
	tipo_variable(typeAt)
	<tSEMICOLON> 
	{ at.code.addBlock(typeAt.code); }
}

//lista_ids: <tID> (<tCOMMA> <tID>)*
/**
 * Params:
 * 	-tokens: lista de tokens de la enumeraci칩n de los identificadores de las variables
 */
void lista_ids(TypeAttrib typeAt) :
{
	Token t;
}
{
	t = <tID> {typeAt.t.add(t);}
	(<tCOMMA> t = <tID> {typeAt.t.add(t);})*
}

//tipo_variable: (tipo_variable_simple | tipo_variable_array)
/**
 * Params: 
 *	-t: lista de tokens de la enumeraci칩n de los identificadores de las variables
 *	-paramArray: creado y utilizado en la producci칩n "parametro_formal" para rellenar los datos de un par치metro ARRAY
 *	-paramClass: valor != de NONE en caso de ser un par치metro
 */
Symbol.Types tipo_variable(TypeAttrib typeAt) : 
{
	Symbol.Types baseType = Symbol.Types.ARRAY; // Si no es tipo simple, es un array

	TypeAttrib typeAt1 = new TypeAttrib(), typeAt2 = new TypeAttrib();
	typeAt1.clone(typeAt); typeAt2.clone(typeAt);
	typeAt1.paramArray = null;
}
{
	( 
		baseType = tipo_variable_simple(typeAt1) { typeAt.code.addBlock(typeAt1.code); }
	|   		   tipo_variable_array(typeAt2)  { typeAt.code.addBlock(typeAt2.code); }
	)
	{ return baseType; } // Si es un tipo simple, se devuelve el tipo de la variable
}

//tipo_variable_array: <tARRAY> <tLPAREN> <tCONST_INT> <tRANGE> <tCONST_INT> <tRPAREN> <tOF> tipo_variable_simple
/**
 * Params:
 *	-t: lista de tokens de la enumeraci칩n de los identificadores de las variables
 *	-paramArray: necesario para heredar el valor de la producci칩n previa "tipo_variable"
 *	-paramClass: valor != de NONE en caso de ser un par치metro (heredado de "tipo_variable")
 */
void tipo_variable_array(TypeAttrib typeAt) : 
{
	ArrayTypeAttrib arrayTypeAt = new ArrayTypeAttrib();
	boolean isParameter = (typeAt.paramClass != Symbol.ParameterClass.NONE);
	boolean isDeclaration = !isParameter;
	TypeAttrib typeAt2;
}
{
	<tARRAY> <tLPAREN>
	(<tMINUS> {arrayTypeAt.minus1 = -1;} | <tPLUS>)? arrayTypeAt.tMin = <tCONST_INT> 
		<tRANGE> 
	(<tMINUS> {arrayTypeAt.minus2 = -1;} | <tPLUS>)? arrayTypeAt.tMax = <tCONST_INT> 
	<tRPAREN>
	{
		arrayTypeAt.min = Integer.parseInt(arrayTypeAt.tMin.image) * arrayTypeAt.minus1;
		arrayTypeAt.max = Integer.parseInt(arrayTypeAt.tMax.image) * arrayTypeAt.minus2;
		semantic.emptyArrayRange(arrayTypeAt.tMax, arrayTypeAt.min, arrayTypeAt.max); // Comprobar que el rango no es vac칤o (min > max)

		if (isDeclaration) {
			arrayTypeAt.baseArray = new SymbolArray("", arrayTypeAt.min, arrayTypeAt.max, Symbol.Types.UNDEFINED, typeAt.paramClass);
			/* baseArray se crea aqu칤 para que en "tipo_variable_simple" se pueda
			   insertar en la tabla de s칤mbolos con los valores de "min" y "max" */
		}
	}
	<tOF> { typeAt2 = new TypeAttrib(); typeAt2.clone(typeAt); typeAt2.paramArray = arrayTypeAt.baseArray; }
	arrayTypeAt.baseType = tipo_variable_simple(typeAt2)
	{
		if (isParameter){ // Par치metro ARRAY
			// paramArray se ha creado en "parametro_formal" para rellenarse aqu칤
			typeAt.paramArray.minInd = arrayTypeAt.min;
			typeAt.paramArray.maxInd = arrayTypeAt.max;
			typeAt.paramArray.parClass = typeAt.paramClass;
			typeAt.paramArray.baseType = arrayTypeAt.baseType;
		}
	}
}

//tipo_variable_simple: <tINT> | <tCHAR> | <tBOOL>
/*
 Params:
	-t: lista de tokens de la enumeraci칩n de los identificadores de las variables
	-baseArray: creado en "tipo_variable_array" para rellenar datos del array (칤ndices y paramClass). 
				En esta producci칩n se termina de rellenar (nombre) y se inserta en la tabla de s칤mbolos.
	-paramClass: valor != de NONE en caso de ser un par치metro
 */
Symbol.Types tipo_variable_simple(TypeAttrib typeAt) : 
{
	// Symbol.Types type = null;
	boolean isArray = (typeAt.paramArray != null);
	/* Si baseArray != de null, estamos en una declaraci칩n de
	   array y contiene los valores de min, max y paramClass */
}
{
	( <tINT>  { typeAt.type = Symbol.Types.INT; }
	| <tCHAR> { typeAt.type = Symbol.Types.CHAR; }
	| <tBOOL> { typeAt.type = Symbol.Types.BOOL; }
	)
	{
		if (typeAt.t == null) { // Par치metros
			/* Si no hay tokens, devolver el tipo de la variable porque se est치n leyendo par치metros
			   y estos se insertan en st en declaracion_procedimiento y declaracion_funcion */
			return typeAt.type;
		}
		else if (isArray) { // Declaraci칩n de variables arrays
			typeAt.paramArray.baseType = typeAt.type;
			for (Token id : typeAt.t) { 
				SymbolArray newArray = typeAt.paramArray.clone(); // Necesario para obtener un array nuevo con la info de 칤ndices y paramClass
				newArray.name = id.image;
				semantic.insertSymbol(id, newArray, null);
			}
		} else { // Declaraci칩n de variables simples
			for (Token id : typeAt.t) {
				/*游꾺 Hacer funci칩n de generaci칩n de c칩digo que realice:
					- Aumentar espacio requerido
					- Asignar direcci칩n (lugar en memoria)
				*/
				switch (typeAt.type) {
					case INT:  semantic.insertSymbol(id, new  SymbolInt(id.image, typeAt.paramClass), null); break;
					case CHAR: semantic.insertSymbol(id, new SymbolChar(id.image, typeAt.paramClass), null); break;
					case BOOL: semantic.insertSymbol(id, new SymbolBool(id.image, typeAt.paramClass), null); break;
				}
			}
		}
		return typeAt.type;
	}
}

//declaracion_procedimiento: <tPROCDURE> <tID> (<tLPAREN> lista_parametros <tRPAREN>)? <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
void declaracion_procedimiento(Attributes at) : 
{
	FuncProcDecAttrib funcProcDecAt = new FuncProcDecAttrib();
	Attributes at1 = new Attributes();
}
{
	<tPROCEDURE>
	funcProcDecAt.id = <tID> // Puede NO tener par치metros
	( <tLPAREN> lista_parametros(funcProcDecAt) <tRPAREN> )?
	{
		
		semantic.insertSymbol(funcProcDecAt.id, new SymbolProcedure(funcProcDecAt.id.image, new ArrayList<Symbol>(funcProcDecAt.params.values())), null);
		semantic.insertBlock();
		// insertar params con los tokens en la tabla de s칤mbolos DESPU칄S de crear un nuevo bloque
		for (Map.Entry<Token, Symbol> entry : funcProcDecAt.params.entrySet()) {
			semantic.insertSymbol(entry.getKey(), entry.getValue(), null);
		}
	}
	<tIS>
		(declaracion_var(at))*
		( declaracion_procedimiento(funcProcDecAt) | declaracion_funcion(funcProcDecAt) )*
	<tBEGIN>
		(instruccion(at1))+
	<tEND>
	<tSEMICOLON>
	{
		if (verbose) semantic.printSymbolTable(funcProcDecAt.id.image); // Impresi칩n de la tabla de s칤mbolos
		semantic.removeBlock(); // Eliminaci칩n del bloque actual
		at.code.addBlock(funcProcDecAt.code);
		at.code.addBlock(at1.code);
		at.code.addInst(PCodeInstruction.OpCode.CSF);
	}
}

//declaracion_funcion: <tFUNCTION> <tID> ( <tLPAREN> lista_parametros <tRPAREN> )? <tRETURN> tipo_variable_simple <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
void declaracion_funcion(Attributes at) : 
{
	TypeAttrib typeAt = new TypeAttrib();
	FuncProcDecAttrib funcProcDecAt = new FuncProcDecAttrib();
	Attributes at1 = new Attributes();
	String label;
}
{
	{ label = CGUtils.newLabel(); }
	<tFUNCTION>
	funcProcDecAt.id = <tID>
	( <tLPAREN> lista_parametros(funcProcDecAt) <tRPAREN> )? // Puede NO tener par치metros
	<tRETURN> {typeAt.t = null;}
	funcProcDecAt.returnType = tipo_variable_simple(typeAt)
	{
		funcProcDecAt.functionSymbol = new SymbolFunction(funcProcDecAt.id.image, new ArrayList<Symbol>(funcProcDecAt.params.values()), funcProcDecAt.returnType);
		semantic.insertSymbol(funcProcDecAt.id, funcProcDecAt.functionSymbol, label);
		semantic.insertBlock();
		// insertar params con los tokens en la tabla de s칤mbolos DESPU칄S de crear un nuevo bloque
		for (Map.Entry<Token, Symbol> entry : funcProcDecAt.params.entrySet()) {
			semantic.insertSymbol(entry.getKey() ,entry.getValue(), null);
		}
	}
	<tIS>
		(declaracion_var(at))*
		( declaracion_procedimiento(funcProcDecAt) | declaracion_funcion(funcProcDecAt) )*
	<tBEGIN> {semantic.enterFunction(funcProcDecAt.functionSymbol);}
		(instruccion(at1))+
	<tEND>
	{
		semantic.exitFunction(getToken(0));
		if (verbose) semantic.printSymbolTable(funcProcDecAt.id.image); // Impresi칩n de la tabla de s칤mbolos
		semantic.removeBlock(); // Eliminaci칩n del bloque actual

		at.code.addBlock(funcProcDecAt.code);
		at.code.addBlock(at1.code);
		at.code.addInst(PCodeInstruction.OpCode.CSF);
	}
	<tSEMICOLON>
}


//lista_parametros: parametro_formal (<tSEMICOLON> parametro_formal)*
/**
 * Params:
 * 	-params: Diccionario de Token-Symbol de los par치metros
 */
void lista_parametros(FuncProcDecAttrib funcProcDecAt) : {}
{
	parametro_formal(funcProcDecAt.params) 
	( <tSEMICOLON> parametro_formal(funcProcDecAt.params) )*
}

//parametro_formal: lista_ids <tCOLON> <tREF>? tipo_variable
/**
 * Params:
 * 	-params: Diccionario de Token-Symbol de los par치metros
 */
void parametro_formal(Map<Token,Symbol> params) : 
{
	ParVarAttrib parVarAt = new ParVarAttrib();
	TypeAttrib typeAt = new TypeAttrib();
}
{
	lista_ids(typeAt/* .t */)
	<tCOLON>
	( <tREF> {parVarAt.paramClass = Symbol.ParameterClass.REF;} )?
	{
		typeAt.t = null;
		typeAt.paramArray = parVarAt.paramArray;
		typeAt.paramClass = parVarAt.paramClass;
	}
	parVarAt.baseType = tipo_variable(typeAt) 
	// Aqu칤 es el 칰nico lugar donde se utiliza paramArray ya que aqu칤 se leen par치metros
	// Funciona de manera que en "tipo_variable_array" al ver que paramClass no es NONE (es VAL o REF), se rellenan los datos de paramArray con: min, max y paramClass
	{
		for (Token id : parVarAt.t) {
		// Comprobar si hay alg칰n par치metro con el mismo nombre (se hace tras declarar todos los par치metros)

			if (parVarAt.baseType == Symbol.Types.ARRAY) { // Par치metros array
				SymbolArray newArray = typeAt.paramArray.clone();
				newArray.name = id.image;
				params.put(id, newArray); // Insertado de par치metro array en el diccionario de par치metros
			} else { // Par치metros simples
				switch (parVarAt.baseType) {
					// Insertado de par치metro (int|char|bool) en el diccionario de par치metros
					case INT:  params.put(id, new  SymbolInt(id.image, parVarAt.paramClass)); break;
					case CHAR: params.put(id, new SymbolChar(id.image, parVarAt.paramClass)); break;
					case BOOL: params.put(id, new SymbolBool(id.image, parVarAt.paramClass)); break;
				}
			}
		}
	}
}


/*------------------------------------------- INSTRUCCIONES -------------------------------------------*/ 

//instruccion: (inst_leer | <tSKIP_LINE> | inst_escribir | inst_escribir_linea | inst_invocacion_procedimiento_o_asignacion | inst_if | inst_while | <tNULL> | inst_return) <tSEMICOLON>
void instruccion(Attributes at): 
{
	Attributes at1 = new Attributes();
}
{
	(	inst_leer(at1) {at.code.addBlock(at1.code);}
	|	<tSKIP_LINE> // Nunca recibe argumentos (游꾺 hacer algo del codeBlock?)
	|   inst_escribir(at1) {at.code.addBlock(at1.code);}
	|   inst_escribir_linea(at1) {at.code.addBlock(at1.code);}
	|   inst_invocacion_procedimiento_o_asignacion(at1) {at.code.addBlock(at1.code);}
	|   inst_if(at1) {at.code.addBlock(at1.code);}
	|   inst_while(at1) {at.code.addBlock(at1.code);}
	|   <tNULL> // (游꾺 hacer algo del codeBlock?)
	|   inst_return(at1) {at.code.addBlock(at1.code);}
	)
	<tSEMICOLON>
}

//inst_leer: <tGET> <tLPAREN> inst_leer_elemento ( <tCOMMA> inst_leer_elemento )* <tRPAREN>
void inst_leer(Attributes at) : 
{
	Attributes at1 = new Attributes();
}
{
	<tGET> // Necesita par치metros
	<tLPAREN> 
	inst_leer_elemento(at1)
	( <tCOMMA> inst_leer_elemento(at1) )* 
	<tRPAREN>
}

//inst_leer_elemento: <tID> ( array_access )?
void inst_leer_elemento(Attributes at) :
{
	Attributes at1 = new Attributes();
	Token id;
	boolean access = false;
	/* Se deben leer variables asignables de tipo integer o character.
	   Solo son asignables las variables simples y los elementos de un array */
}
{
	id = <tID> ( array_access(at1) {access = true;} )?
	{
		if (! semantic.isSymbolDefined(id)) return; // El error de s칤mbolo no definido est치 en semantic.isSymbolDefined
		Symbol symbol = semantic.getSymbol(id);

		semantic.isProcedureOrFunction(id, symbol); // si es procedimiento o funci칩n, error

		/* Comprobaciones relacionadas con arrays:
		- Si es array: 
			- comprobar que se ha accedido a un elemento y no al array entero
			- comprobar que el tipo del array es INT o CHAR
		- Si no: que no se acceda a una variable simple, procedimiento o funci칩n como a un array
		*/
		semantic.readingArrayChecks(id, symbol, access);

		semantic.isBooleanBeingRead(id, symbol); // no se puede leer un booleano
	}
}

//array_access: <tLPAREN> expresion <tRPAREN>
void array_access(Attributes at) : 
{
	ExpressionAttrib expAt = new ExpressionAttrib();
	Symbol.Types type; // Se podr칤a a침adir a ExpressionAttrib y asignarlo en la producci칩n "expresion" para no tener que declararlo aqu칤
}
{
	<tLPAREN> 
	type = expresion(expAt)
	{
		semantic.indexIsInteger(getToken(0), type); // Comprobar que el 칤ndice es de tipo INT
		// No hace falta comprobar que el 칤ndice est칠 dentro del rango del array porque no se pide
	}
	<tRPAREN>
}

//inst_escribir: <tPUT> <tLPAREN> inst_escribir_elemento ( <tCOMMA> inst_escribir_elemento )* <tRPAREN>
void inst_escribir(Attributes at) : 
{
	Attributes at1 = new Attributes();
}
{
	<tPUT> // Necesita par치metros
	<tLPAREN> 
	inst_escribir_elemento(at1)
	( <tCOMMA> inst_escribir_elemento(at1) )*
	<tRPAREN>
}

//inst_escribir_elemento: <tCONST_STRING> | expresion
void inst_escribir_elemento(Attributes at) : 
{
	ExpressionAttrib expAt = new ExpressionAttrib();
	Symbol.Types type = Symbol.Types.STRING;
	Token value;
	// Se pueden escribir constantes string y expresiones de tipo integer, character y boolean, incluidos los elementos de un array
}
{
	(value = <tCONST_STRING>
	{
		// System.out.println("Escribiendo string: '" + value.image + "'");
		// System.out.println("Char: '" + value.image.charAt(0) + "'");

		// Iterar en el valor del string y escribir uno a uno los ascii de los caracteres
		for (int i = 0; i < value.image.length(); i++) {
			expAt.code.addInst(PCodeInstruction.OpCode.STC, value.image.charAt(i));
			expAt.code.addInst(PCodeInstruction.OpCode.WRT, 0);
		}
	} | type = expresion(expAt)) 
		// 游꾺 Tratar en las llamadas internas la adici칩n del c칩digo (acabar치 en primario pero habr치 que ir
		// subi칠ndolo de producci칩n en  producci칩n en la cadena expresion>relacion>expresion_simple...)
	{
		// System.out.println("Codigo: " + expAt.code.toString());
		at.code.addBlock(expAt.code);

		switch (type) {
			case INT:
			case BOOL:
			case CHAR:
			case STRING: break;
			case ARRAY: semantic.error(getToken(0), "No se puede escribir un array entero, pero s칤 componentes de array."); break;
			default: semantic.error(getToken(0), 
					"Solo se pueden escribir valores de tipo " + tokenImage[tINT] + ", " + tokenImage[tCHAR] + ", " + tokenImage[tBOOL] + " y " + tokenImage[tCONST_STRING] + ".");
		}
	}
}

//inst_escribir_linea: <tPUT_LINE> (<tLPAREN> inst_escribir_elemento (<tCOMMA> inst_escribir_elemento)* <tRPAREN>)?
void inst_escribir_linea(Attributes at) : 
{
	Boolean hasString = false;
	Attributes at1 = new Attributes();
}
{
	<tPUT_LINE> // Puede NO tener par치metros
	(
		<tLPAREN> inst_escribir_elemento(at1)
		( <tCOMMA> inst_escribir_elemento(at1) )* <tRPAREN>
		{ hasString = true; }
	)?
	{
		if (hasString) {
			at.code.addBlock(at1.code);
		}

		// A침adir el salto de l칤nea: CR + LF (asciis 13 y 10 respectivamente)
		at.code.addInst(PCodeInstruction.OpCode.STC, 13);
		at.code.addInst(PCodeInstruction.OpCode.WRT, 0);
		at.code.addInst(PCodeInstruction.OpCode.STC, 10);
		at.code.addInst(PCodeInstruction.OpCode.WRT, 0);
	}
}

//inst_invocacion_procedimiento_o_asignacion: <tID> (array_access)? (<tASSIGN> expresion | <tLPAREN> lista_una_o_mas_exps <tRPAREN>)?
void inst_invocacion_procedimiento_o_asignacion(Attributes at) : 
{
	Attributes at1 = new Attributes();
	ExpressionAttrib expAt = new ExpressionAttrib();
	Token id;
	Symbol.Types type;
	boolean access = false;
}
{
	id = <tID>
	(
	LOOKAHEAD( (array_access(at1))? <tASSIGN> ) // comprueba si es una asignaci칩n (mediante uso de LOOKAHEAD sint치ctico)
	(array_access(at1) {access = true;} )? 
	<tASSIGN>
	type = expresion(expAt)
	{
		if (! semantic.isSymbolDefined(id)) return; // Si no est치 definido, no se puede comprobar nada m치s
		Symbol symbol = semantic.getSymbol(id);

		/* Comprobaciones relacionadas con arrays:
		- Si es array:
			- se debe acceder a un elemento (el array no es asignable pero sus elementos s칤 lo son)
			- comprobar que el tipo de la expresi칩n coincide con el tipo base del array
		- Si no: no puede accederse a una variable no array
		*/
		semantic.assigningArrayChecks(id, symbol, type, access);

		/* Comprobaciones sobre los tipos de los asignables:
		- Si es un procedimiento o funci칩n, error
		- Asignable y expresi칩n deben ser del mismo tipo
		*/
		semantic.assignableTypeChecks(id, symbol, type); // Solamente son asignables las variables simples y los elementos de un array
	}
	| // invocaci칩n_procedimiento()
	// checkear que el id es un procedimiento y nada m치s
	( <tLPAREN> lista_una_o_mas_exps(id) <tRPAREN> )? 
	{
		if (! semantic.isSymbolDefined(id)) return; // Si no est치 definido, no se puede comprobar nada m치s
		Symbol symbol = semantic.getSymbol(id);

		semantic.procedureChecks(id, symbol); // Comprobar que el s칤mbolo es un procedimiento, y que no es el procedimiento principal
	}
	)
}

//inst_if: <tIF> expresion <tTHEN> instruccion+ (<tELSIF> expresion <tTHEN> instruccion+)* (<tELSE> instruccion+)? <tEND> <IF>
void inst_if(Attributes at) :
{
	ExpressionAttrib expAt = new ExpressionAttrib();
	Attributes at1 = new Attributes();
	Symbol.Types type;
}
{
	<tIF>	  type = expresion(expAt) 
	{
		semantic.ifChecks(getToken(0), type); // Comprobar que la guarda es de tipo BOOL
	}
	<tTHEN> ( instruccion(at1) )+
	(<tELSIF> type = expresion(expAt)
	{
		semantic.ifChecks(getToken(0), type); // Comprobar que la guarda es de tipo BOOL
	} <tTHEN> ( instruccion(at1) )+ )* 
	(<tELSE>  ( instruccion(at1) )+ )? 
	<tEND> <tIF>
}

//inst_while: <tWHILE> expresion <tLOOP> instruccion+ <tENDLOOP>
void inst_while(Attributes at) : 
{
	ExpressionAttrib expAt = new ExpressionAttrib();
	Attributes at1 = new Attributes();
	Symbol.Types type;
}
{
	<tWHILE> type = expresion(expAt)
	{
		semantic.whileChecks(getToken(0), type); // Comprobar que la guarda es de tipo BOOL
	}
	<tLOOP> ( instruccion(at1) )+ <tEND> <tLOOP>
}

//inst_return: <tRETURN> expresion
void inst_return(Attributes at) : 
{
	ExpressionAttrib expAt = new ExpressionAttrib();
	Symbol.Types returnType;
	Token t;
}
{
	t = <tRETURN> returnType = expresion(expAt) 
	{
		semantic.inst_return(t, returnType);
	}
}

/*--------------------------------------- EXPRESIONES ---------------------------------------*/ 

//expresion: relacion ( (<tAND> relacion)+ | (<tOR> relacion)+ )?
/** 游꾺 REVISAR MAIL QUE MAND칍 (20/4) SOBRE FALLO EN ESTA PRODUCCI칍N
 * Params:
 * -param: != de null si es un par치metro de funci칩n/procedimiento, o bien una componente de un vector
 * -esAsignable: array de un 칰nico booleano para comprobar si la expresi칩n es asignable. Debe ser un array
 * 				 para ser un elemento mutable y poder modificar su valor en las producciones que lo necesiten.
 */
Symbol.Types expresion(ExpressionAttrib expAt) : 
{
	Symbol.Types type;
	boolean moreThanOne = false;
	String errorMsg = "Las relaciones de una expresi칩n l칩gica deben ser de tipo " + tokenImage[tBOOL] + ".";

	ExpressionAttrib expAt2 = new ExpressionAttrib(); // Se inicia con null, null
}
{
	type = relacion(expAt)
	(	(<tAND>
		{
			moreThanOne = true;
			if (type != Symbol.Types.BOOL)
				semantic.error(getToken(0), errorMsg);
		}
		type = relacion(expAt2) 
		{
			// Si hay m치s de una relaci칩n, deben ser todas BOOL
			if (type != Symbol.Types.BOOL)
				semantic.error(getToken(0), errorMsg);
		}
		)+
		| (<tOR>
		{
			moreThanOne = true;
			if (type != Symbol.Types.BOOL)
				semantic.error(getToken(0), errorMsg);
		}
		type = relacion(expAt2)
		{
			// Si hay m치s de una relaci칩n, deben ser todas BOOL
			if (type != Symbol.Types.BOOL)
				semantic.error(getToken(0), errorMsg);
		}
		)+
	)?
	{
		if (moreThanOne && expAt.esAsignable != null) expAt.esAsignable = false; // Si hay m치s de una relaci칩n, la expresi칩n no es asignable
		return (moreThanOne) ? Symbol.Types.BOOL : type;
	}
}

//relacion: expresion_simple (operador_relacional expresion_simple)?
/**
 * Params: an치logo a los de la producci칩n "expresion"
 */
Symbol.Types relacion(ExpressionAttrib expAt) : 
{
	Symbol.Types type1, type2 = Symbol.Types.UNDEFINED;
	ExpressionAttrib expAt2 = new ExpressionAttrib();
}
{
	type1 = expresion_simple(expAt)
 	( operador_relacional() type2 = expresion_simple(expAt2) )?
	{
		// Puede haber una o dos expresiones, pero si hay dos, deben ser del mismo tipo
		if (type2 != Symbol.Types.UNDEFINED) {
			if (expAt.esAsignable != null) expAt.esAsignable = false; // Si hay dos expresiones, la expresi칩n no es asignable
			if (type1 != type2)
				semantic.error(getToken(0), "Las expresiones de una relaci칩n deben ser del mismo tipo, se encontr칩 " + type1 + " y " + type2 + ".");

			return Symbol.Types.BOOL; // Si hay dos expresiones, el resultado es booleano
		}
		// else: si hay solo una expresi칩n, se devuelve su tipo
		return type1;
	}
}

//operador_relacional: (<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
void operador_relacional() : {}
{
	(<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
}

//expresion_simple: ( <tPLUS> |	<tMINUS> )? termino ( ( <tPLUS> | <tMINUS> ) termino )*
/**
 * Params: an치logo a los de la producci칩n "expresion"
 */
Symbol.Types expresion_simple(ExpressionAttrib expAt) : 
{
	Symbol.Types type;
	boolean sign = false;
	ExpressionAttrib expAt2 = new ExpressionAttrib();
}
{
    ((<tPLUS> | <tMINUS>) {sign = true;}  )? type = termino(expAt) 
	{
		semantic.signInExpressionCheck(getToken(0), type, sign); // Si hay signo, la expresi칩n debe ser de tipo INT
	}
	(( <tPLUS> | <tMINUS> )  type = termino(expAt2)
	{
		sign = true;
		semantic.moreThanOneExpressionCheck(getToken(0), type); // Si hay m치s de un t칠rmino, deben ser todos INT
	}
	)*
	{
		if (sign && expAt.esAsignable != null) expAt.esAsignable = false; // Si hay signo o m치s de un t칠rmino, la expresi칩n no es asignable
		return (sign) ? Symbol.Types.INT : type;
	}
}
                                                                                                                                                                         
//termino: factor (operador_multiplicativo factor)*
/**
 * Params: an치logo a los de la producci칩n "expresion"
 */
Symbol.Types termino(ExpressionAttrib expAt) : 
{
	Symbol.Types type;
	boolean moreThanOne = false;
	ExpressionAttrib expAt2 = new ExpressionAttrib();
}
{
    type = factor(expAt) 
	( operador_multiplicativo()
		{
			moreThanOne = true;
			semantic.multiplicativeFactorCheck(getToken(0), type); // Los factores deben ser todos INT para poder operar con *, /, %
		}
	type = factor(expAt2)
		{ 
			// Si hay m치s de un factor, deben ser todos INT
			semantic.multiplicativeFactorCheck(getToken(0), type); // Los factores deben ser todos INT para poder operar con *, /, %
		}
	)*
	{
		if (moreThanOne && expAt.esAsignable != null) expAt.esAsignable = false; // Si hay m치s de un factor, la expresi칩n no es asignable
		return (moreThanOne) ? Symbol.Types.INT : type;
	}
}

//operador_multiplicativo: (<tMULT> | <tDIV> | <tMOD>)
void operador_multiplicativo() : {}
{
	(<tMULT> | <tDIV> | <tMOD>)
}

//factor: (<tNOT>)? primario
/**
 * Params: an치logo a los de la producci칩n "expresion"
 */
Symbol.Types factor(ExpressionAttrib expAt) : 
{
	Symbol.Types type;
	boolean not = false;
	ExpressionAttrib expAt1 = new ExpressionAttrib();
	expAt1.clone(expAt);
}
{
	( <tNOT> {not = true;} )? type = primario(expAt1) 
	{
		if (not) {
			if (expAt1.esAsignable != null) expAt1.esAsignable = false;
			semantic.notOperatorCheck(getToken(0), type); // Operador 'not' solo se puede usar con variables de tipo BOOL 

			expAt.code.addBlock(expAt1.code);
			expAt.code.addInst(PCodeInstruction.OpCode.NGB);

			return Symbol.Types.BOOL;
		}

		return type;
	}
}

//primario: <tLPAREN> expresion <tRPAREN> | <tINT2CHAR> <tLPAREN> expresion <tRPAREN> | <tCHAR2INT> <tLPAREN> expresion <tRPAREN> 
//			| <tID> <tLPAREN> lista_una_o_mas_exps <tRPAREN> | <tID> | <tCONST_INT> | <tCONST_CHAR> | <tTRUE> | <tFALSE>
/**
 * Params: an치logo a los de la producci칩n "expresion"
 */
Symbol.Types primario(ExpressionAttrib expAt) : 
{
	ExpressionAttrib expAt2 = new ExpressionAttrib();
	Symbol.Types type = Symbol.Types.UNDEFINED;
	Token id;
}
{
	(			    <tLPAREN> type = expresion(expAt2) <tRPAREN>
	|	<tINT2CHAR> <tLPAREN> type = expresion(expAt2) <tRPAREN>
	{
		semantic.int2charCheck(getToken(0), type); // La expresi칩n debe ser de tipo INT
		type = Symbol.Types.CHAR;
	}
	|	<tCHAR2INT> <tLPAREN> type = expresion(expAt2) <tRPAREN>
	{
		// La expresio칩n debe ser de tipo CHAR
		semantic.char2intCheck(getToken(0), type); // La expresi칩n debe ser de tipo CHAR
		type = Symbol.Types.INT;
	}
	|	LOOKAHEAD (2) id = <tID> <tLPAREN> lista_una_o_mas_exps(id) <tRPAREN> //invocar func. (con par치metros) o comp. array
	{
		if (! semantic.isSymbolDefined(id)) return Symbol.Types.UNDEFINED;
		Symbol symbol = semantic.getSymbol(id);

		switch (symbol.type) {
			// Si es una funci칩n, devolver su tipo retorno
			case FUNCTION: type = ((SymbolFunction) symbol).returnType; break;
			// Checkear que no es procedimiento 
			case PROCEDURE: semantic.procedureInPrimaryError(id, "funci칩n"); break;
			case ARRAY:
				type = ((SymbolArray) symbol).baseType; // Si es un array, devolver su tipo base
				if (expAt.esAsignable != null) expAt.esAsignable = true;
				id.clone(expAt.param);
				break;
			default: type = symbol.type;
		}
	}
	|	id = <tID> // variable simple o func/proced sin par치metros
	{
		if (! semantic.isSymbolDefined(id)) return Symbol.Types.UNDEFINED;
		Symbol symbol = semantic.getSymbol(id);

		switch (symbol.type) {
			case FUNCTION: 
				SymbolFunction function = (SymbolFunction) symbol;
				semantic.functionParametersCheck(id, function); // Checkear que la funci칩n no tenga par치metros
				type = function.returnType;
				break;
			// Checkear que no es procedimiento
			case PROCEDURE: semantic.procedureInPrimaryError(id, "variable"); break; 
			// Si es un array y no se espera un par치metro, debe accederse a un elemento
			case ARRAY: semantic.arrayAccessCheck(id, expAt.param); 
			default:
				id.clone(expAt.param);
				if (expAt.esAsignable != null) expAt.esAsignable = true;
				type = symbol.type;
		}
	}
	|	<tCONST_INT>  {type = Symbol.Types.INT; } // 游꾺 aqu칤 habr치 que guardar el valor del int y hacer: STC (ascii del int) + WRT 1
	|	<tCONST_CHAR> {type = Symbol.Types.CHAR;} // 游꾺 STC (ascii del char) + WRT 0
	|	<tTRUE> 	  {type = Symbol.Types.BOOL;} // 游꾺 STC 1 + WRT 0
	|	<tFALSE> 	  {type = Symbol.Types.BOOL;} // 游꾺 STC 0 + WRT 0
	)
	{
		return type;
	}
}

//lista_una_o_mas_exps: expresion() ( <tCOMMA> expresion() )*
/**
 * Params:
 * 	-id: Token de la funci칩n/procedimiento invocado, o del array accedido
 */
void lista_una_o_mas_exps(Token id) : 
{ // Se ejecuta en una invocaci칩n de funci칩n o procedimiento y en el acceso a un array en una expresi칩n
	List<Symbol.Types> types = new ArrayList<>();
	Map<Token, Boolean> args = new LinkedHashMap<>();

	Symbol.Types type;
	if (! semantic.isSymbolDefined(id)) return; // Si no se ha definido el s칤mbolo (error sem치ntico previo en primario)
	Symbol symbol = semantic.getSymbol(id);
	
	ExpressionAttrib expAt = new ExpressionAttrib();
}
{
	{
		expAt.param = new Token(0);
		expAt.esAsignable = false;
	}
	type = expresion(expAt)
	{
		types.add(type);
		if (expAt.param.kind == 0) args.put(getToken(0), false);
		else 			 		   args.put(expAt.param, expAt.esAsignable);
		expAt.esAsignable = false;
		expAt.param = new Token(0);
	}
	( <tCOMMA> type = expresion(expAt) 
		{ // Iterate over all the parameters
			types.add(type);
			if (expAt.param.kind == 0) args.put(getToken(0), false); // Si no se ha sobrescrito t, se a침ade el token actual
			else 			 		   args.put(expAt.param, expAt.esAsignable);
			expAt.esAsignable = false;
			expAt.param = new Token(0);
		}
	)*
	{
		if (symbol.type == Symbol.Types.FUNCTION || symbol.type == Symbol.Types.PROCEDURE) {

			// Recuperar lista par치metros del Token 'id' 
			List<Symbol> parList = (symbol instanceof SymbolFunction) ? ((SymbolFunction) symbol).parList : ((SymbolProcedure) symbol).parList;

			// Comprobar que el n칰mero de argumentos coincide con el n칰mero de par치metros
			String msg = (symbol.type == Symbol.Types.FUNCTION) ? "de la funci칩n" : "del procedimiento";
			msg += " '" + id.image + "'";
			if (semantic.checkNumberOfArguments(id, parList.size(), types.size(), msg)) return; // Si no coinciden los par치metros, salir

			// Comprobar que los tipos de los argumentos coinciden con los tipos de los par치metros
			semantic.checkArgumentTypes(id, types, parList, args, msg);

		} else if (symbol.type == Symbol.Types.ARRAY) {
			/*Comprobaciones sobre el array
			- El acceso a un array debe tener un 칰nico 칤ndice
			- El 칤ndice de un array debe ser de tipo integer
			*/ 
			semantic.arrayInListOfExpressionCheck(id, types);
		} else { // Si id es un tipo simple, no puede accederse a un elemento
			semantic.error(id, "No se puede acceder a un elemento del s칤mbolo '" + id.image + "' por ser de tipo " + symbol.type + " y no " + tokenImage[tARRAY] + ".");
		}
	}
}
