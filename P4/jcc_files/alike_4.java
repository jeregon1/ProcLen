/* alike_4.java */
/* Generated By:JavaCC: Do not edit this line. alike_4.java */
package traductor;

import java.io.FileWriter;
import java.io.File;
import java.io.IOException;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.SemanticFunctions.SemanticFunctions;
import lib.attributes.*;

import lib.tools.codeGeneration.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;

public class alike_4 implements alike_4Constants {

        static SemanticFunctions semantic; // Funciones semánticas

        static boolean verbose = false; // Flag modo verbose (impresión bloque cerrado tabla de símbolos)

        public static void main(String[] args) {
                alike_4 parser = null;

                // argumento verbose
                if (args.length > 1 && args[1].equals("-v")) {
                        verbose = true;
                }

                // creación de SemanticFuncions, donde se encapsula la lógica semántica junto a la tabla de símbolos
                semantic = new SemanticFunctions();
                String fileName = "";

                try {
                        if(args.length == 0) { // Si no se especifica fichero, se lee de la entrada estándar
                                parser = new alike_4(System.in);
                        }
                        else {
                                fileName = args[0];
                                parser = new alike_4(new java.io.FileInputStream(fileName+".al"));
                        }
                        //Programa es el símbolo inicial de la gramática
                        parser.Programa(fileName);

                        if (!semantic.hayErrores()) {
                                fileName = fileName.substring(0, fileName.lastIndexOf('.')); // Eliminar extensión
                                System.out.println("Compilaci\u00f3n finalizada. Se ha generado el fichero " + fileName + ".pcode");
                        }
                        else
                                if (semantic.getNumErrores() == 1) {
                                        System.out.println("Detectado 1 error sem\u00e1ntico. No se genera c\u00f3digo.");
                                } else {
                                        System.out.println("Detectados " + semantic.getNumErrores() + " errores sem\u00e1nticos. No se genera c\u00f3digo.");
                                }
                }
                catch (java.io.FileNotFoundException e) {
                        System.err.println ("Fichero " + fileName + ".al" +" no encontrado.");
                }
                catch (TokenMgrError e) {
                        System.err.println("ERROR L\u00c9XICO: " + e.getMessage());
                }
                catch (ParseException e) {
                        System.err.println("----------------------------------------");
                        System.err.println(e.getMessage());
                }
                catch (Exception e) {
                        e.printStackTrace();
                }
   }

//------------ Símbolo inicial de la gramática.
// Programa: <tPROCEDURE> <tID> <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instruccion+ <tEND> <tSEMICOLON> <EOF>
  static final public void Programa(String file) throws ParseException {Token id;
        CodeBlock programa;
        Attributes at = new Attributes(), at1 = new Attributes();
        String label;
// Inicialización del programa
                label = CGUtils.newLabel();
                programa = new CodeBlock();
                programa.addInst(PCodeInstruction.OpCode.ENP, label); // Enter Program en 'label', definido justo arriba

    jj_consume_token(tPROCEDURE);
    id = jj_consume_token(tID);
// Procedimiento principal
                semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>()), label);
                semantic.setMainProcedureName(id.image);
    jj_consume_token(tIS);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      declaracion_var(at);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento(at);
        break;
        }
      case tFUNCTION:{
        declaracion_funcion(at);
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
    label_3:
    while (true) {
      instruccion(at1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tEXIT:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tSEMICOLON);
if (verbose) semantic.printSymbolTable(id.image); // Impresión de la tabla de símbolos
                programa.addBlock(at.code);
                programa.addLabel(label); // Añadir la etiqueta de inicio del programa
                programa.addBlock(at1.code);
                programa.addInst(PCodeInstruction.OpCode.LVP); // Leave Program
                if (!semantic.hayErrores()) {
                        // file = file.substring(0, file.lastIndexOf('.')); // Eliminar extensión
                        File f = new File(file + ".pcode");
                        System.out.println("Generando fichero " + file + ".pcode");
                        try {
                                FileWriter fw = new FileWriter(f);
                                fw.write(programa.toString());
                                fw.close();
                        }
                        catch (IOException e) {
                                System.err.println("Error al abrir el fichero");
                        }
                }
}

//declaracion_var: lista_ids <tCOLON> tipo_variable <tSEMICOLON>
  static final public void declaracion_var(Attributes at) throws ParseException {TypeAttrib typeAt = new TypeAttrib();
    lista_ids(typeAt.t);
    jj_consume_token(tCOLON);
    tipo_variable(typeAt);
    jj_consume_token(tSEMICOLON);
at.code.addBlock(typeAt.code);
}

//lista_ids: <tID> (<tCOMMA> <tID>)*
/**
 * Params:
 * 	-tokens: lista de tokens de la enumeración de los identificadores de las variables
 */
  static final public void lista_ids(List<Token> list) throws ParseException {Token t;
    t = jj_consume_token(tID);
list.add(t);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      jj_consume_token(tCOMMA);
      t = jj_consume_token(tID);
list.add(t);
    }
}

//tipo_variable: (tipo_variable_simple | tipo_variable_array)
/**
 * Params: 
 *	-t: lista de tokens de la enumeración de los identificadores de las variables
 *	-paramArray: creado y utilizado en la producción "parametro_formal" para rellenar los datos de un parámetro ARRAY
 *	-paramClass: valor != de NONE en caso de ser un parámetro
 */
  static final public void tipo_variable(TypeAttrib typeAt) throws ParseException {TypeAttrib typeAt1 = new TypeAttrib(), typeAt2 = new TypeAttrib();
        typeAt1.clone(typeAt); typeAt2.clone(typeAt);
        typeAt1.paramArray = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tINT:
    case tCHAR:
    case tBOOL:{
      tipo_variable_simple(typeAt1);
typeAt.code.addBlock(typeAt1.code);
                        typeAt.type = typeAt1.type;     // Si es un tipo simple, se asigna el tipo de la variable

      break;
      }
    case tARRAY:{
      tipo_variable_array(typeAt2);
typeAt.code.addBlock(typeAt2.code);
                        typeAt.type = typeAt2.type;
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

//tipo_variable_array: <tARRAY> <tLPAREN> <tCONST_INT> <tRANGE> <tCONST_INT> <tRPAREN> <tOF> tipo_variable_simple
/*
	-t: lista de tokens de la enumeración de los identificadores de las variables
	-paramArray: necesario para heredar el valor de la producción previa "tipo_variable"
	-paramClass: valor != de NONE en caso de ser un parámetro (heredado de "tipo_variable")
 */
  static final public void tipo_variable_array(TypeAttrib typeAt) throws ParseException {ArrayTypeAttrib arrayTypeAt = new ArrayTypeAttrib();
        boolean isParameter = (typeAt.paramClass != Symbol.ParameterClass.NONE);
        boolean isDeclaration = !isParameter;
        TypeAttrib typeAt2;
    jj_consume_token(tARRAY);
    jj_consume_token(tLPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMINUS:{
        jj_consume_token(tMINUS);
arrayTypeAt.minus1 = -1;
        break;
        }
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    arrayTypeAt.tMin = jj_consume_token(tCONST_INT);
    jj_consume_token(tRANGE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMINUS:{
        jj_consume_token(tMINUS);
arrayTypeAt.minus2 = -1;
        break;
        }
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    arrayTypeAt.tMax = jj_consume_token(tCONST_INT);
    jj_consume_token(tRPAREN);
arrayTypeAt.min = Integer.parseInt(arrayTypeAt.tMin.image) * arrayTypeAt.minus1;
                arrayTypeAt.max = Integer.parseInt(arrayTypeAt.tMax.image) * arrayTypeAt.minus2;
                semantic.emptyArrayRange(arrayTypeAt.tMax, arrayTypeAt.min, arrayTypeAt.max); // Comprobar que el rango no es vacío (min > max)

                if (isDeclaration) {
                        arrayTypeAt.baseArray = new SymbolArray("", arrayTypeAt.min, arrayTypeAt.max, Symbol.Types.UNDEFINED, typeAt.paramClass);
                        /* baseArray se crea aquí para que en "tipo_variable_simple" se pueda
			   insertar en la tabla de símbolos con los valores de "min" y "max" */
                }
    jj_consume_token(tOF);
typeAt2 = new TypeAttrib(); typeAt2.clone(typeAt); typeAt2.paramArray = arrayTypeAt.baseArray;
    tipo_variable_simple(typeAt2);
arrayTypeAt.baseType = typeAt2.type;
if (isParameter){ // Parámetro ARRAY
                        // paramArray se ha creado en "parametro_formal" para rellenarse aquí
                        typeAt.paramArray.minInd = arrayTypeAt.min;
                        typeAt.paramArray.maxInd = arrayTypeAt.max;
                        typeAt.paramArray.parClass = typeAt.paramClass;
                        typeAt.paramArray.baseType = arrayTypeAt.baseType;
                }
                typeAt.type = Symbol.Types.ARRAY;
}

//tipo_variable_simple: <tINT> | <tCHAR> | <tBOOL>
/*
	-t: lista de tokens de la enumeración de los identificadores de las variables
	-paramArray: creado en "tipo_variable_array" para rellenar datos del array (índices y paramClass). 
				En esta producción se termina de rellenar (nombre) y se inserta en la tabla de símbolos.
	-paramClass: valor != de NONE en caso de ser un parámetro
 */
  static final public void tipo_variable_simple(TypeAttrib typeAt) throws ParseException {boolean isArray = (typeAt.paramArray != null);
        /* Si paramArray != de null, estamos en una declaración de
	   array y contiene los valores de min, max y paramClass */

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tINT:{
      jj_consume_token(tINT);
typeAt.type = Symbol.Types.INT;
      break;
      }
    case tCHAR:{
      jj_consume_token(tCHAR);
typeAt.type = Symbol.Types.CHAR;
      break;
      }
    case tBOOL:{
      jj_consume_token(tBOOL);
typeAt.type = Symbol.Types.BOOL;
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (typeAt.t == null) { // Parámetros
                        /* Si no hay tokens, devolver el tipo de la variable porque se están leyendo parámetros
			   y estos se insertan en la st en 'declaracion_procedimiento' y 'declaracion_funcion' */
                        {if ("" != null) return;}
                }
                else if (isArray) { // Declaración de variables arrays
                        typeAt.paramArray.baseType = typeAt.type;
                        for (Token id : typeAt.t) {
                                SymbolArray newArray = typeAt.paramArray.clone(); // Necesario para obtener un array nuevo con la info de índices y paramClass
                                newArray.name = id.image;
                                semantic.insertSymbol(id, newArray, null);
                        }
                } else { // Declaración de variables simples
                        for (Token id : typeAt.t) {
                                /*🎃 Hacer función de generación de código que realice:
					- Aumentar espacio requerido
					- Asignar dirección (lugar en memoria)
				*/
                                switch (typeAt.type) {
                                        case INT:  semantic.insertSymbol(id, new  SymbolInt(id.image, typeAt.paramClass), null); break;
                                        case CHAR: semantic.insertSymbol(id, new SymbolChar(id.image, typeAt.paramClass), null); break;
                                        case BOOL: semantic.insertSymbol(id, new SymbolBool(id.image, typeAt.paramClass), null); break;
                                }
                        }
                }
}

//declaracion_procedimiento: <tPROCDURE> <tID> (<tLPAREN> lista_parametros <tRPAREN>)? <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
  static final public void declaracion_procedimiento(Attributes at) throws ParseException {FuncProcDecAttrib funcProcDecAt = new FuncProcDecAttrib();
        Attributes at1 = new Attributes();
        String label;
label = CGUtils.newLabel();
                at1.code.addLabel(label);
    jj_consume_token(tPROCEDURE);
    funcProcDecAt.id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      lista_parametros(funcProcDecAt);
      jj_consume_token(tRPAREN);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
semantic.insertSymbol(funcProcDecAt.id, new SymbolProcedure(funcProcDecAt.id.image, new ArrayList<Symbol>(funcProcDecAt.params.values())), label);
                semantic.insertBlock();

                int params_size = funcProcDecAt.params.size();
                if (params_size > 0) {
                                // Se insertan params con los tokens en la tabla de símbolos DESPUÉS de crear un nuevo bloque
                        for (Map.Entry<Token, Symbol> entry : funcProcDecAt.params.entrySet()) {
                                semantic.insertSymbol(entry.getKey(), entry.getValue(), null);
                        }

                        // Desapilado de parámetros en orden inverso
                        List<Token> tokens = new ArrayList<>(funcProcDecAt.params.keySet());
                        int currentLevel = semantic.getCurrentLevel();
                        for (int i = params_size; i > 0; i--) {
                                Symbol symbol = semantic.getSymbol(tokens.get(i-1));
                                at1.code.addInst(PCodeInstruction.OpCode.SRF, currentLevel - symbol.nivel, i+2);
                                at1.code.addInst(PCodeInstruction.OpCode.ASGI);
                        }
                }
    jj_consume_token(tIS);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      declaracion_var(at1);
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento(funcProcDecAt);
        break;
        }
      case tFUNCTION:{
        declaracion_funcion(funcProcDecAt);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
label = CGUtils.newLabel();
                        at1.code.addInst(PCodeInstruction.OpCode.JMP, label); // Salto a la instrucción de inicio del procedimiento
                        at1.code.addLabel(label); // Etiqueta de inicio del procedimiento

    label_7:
    while (true) {
      instruccion(at1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tEXIT:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        break label_7;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tSEMICOLON);
if (verbose) semantic.printSymbolTable(funcProcDecAt.id.image); // Impresión de la tabla de símbolos
                semantic.removeBlock(); // Eliminación del bloque actual
                at.code.addBlock(at1.code);
                at.code.addBlock(funcProcDecAt.code);
                at.code.addInst(PCodeInstruction.OpCode.CSF);
}

//declaracion_funcion: <tFUNCTION> <tID> ( <tLPAREN> lista_parametros <tRPAREN> )? <tRETURN> tipo_variable_simple <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
  static final public void declaracion_funcion(Attributes at) throws ParseException {TypeAttrib typeAt = new TypeAttrib();
        FuncProcDecAttrib funcProcDecAt = new FuncProcDecAttrib();
        Attributes at1 = new Attributes();
        String label;
label = CGUtils.newLabel();
                at1.code.addLabel(label);
    jj_consume_token(tFUNCTION);
    funcProcDecAt.id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      lista_parametros(funcProcDecAt);
      jj_consume_token(tRPAREN);
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(tRETURN);
typeAt.t = null;
    tipo_variable_simple(typeAt);
funcProcDecAt.returnType = typeAt.type;
funcProcDecAt.functionSymbol = new SymbolFunction(funcProcDecAt.id.image, new ArrayList<Symbol>(funcProcDecAt.params.values()), funcProcDecAt.returnType);
                semantic.insertSymbol(funcProcDecAt.id, funcProcDecAt.functionSymbol, label);
                semantic.insertBlock();

                int params_size = funcProcDecAt.params.size();
                if (params_size > 0) {
                                // Se insertan params con los tokens en la tabla de símbolos DESPUÉS de crear un nuevo bloque
                        for (Map.Entry<Token, Symbol> entry : funcProcDecAt.params.entrySet()) {
                                semantic.insertSymbol(entry.getKey() ,entry.getValue(), null);
                        }

                                // Desapilado de parámetros en orden inverso
                        // level: número de bloques que hay que bajar para obtener la variable
                        int level = 0; // TODO: nivel fijado a 0, no sé si es lo correcto
                        for (int i = params_size; i > 0; i--) {
                                at1.code.addInst(PCodeInstruction.OpCode.SRF, level, i+2);
                                at1.code.addInst(PCodeInstruction.OpCode.ASGI);
                        }
                }
    jj_consume_token(tIS);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        break label_8;
      }
      declaracion_var(at);
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento(funcProcDecAt);
        break;
        }
      case tFUNCTION:{
        declaracion_funcion(funcProcDecAt);
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
semantic.enterFunction(funcProcDecAt.functionSymbol);

                        label = CGUtils.newLabel();
                        at1.code.addInst(PCodeInstruction.OpCode.JMP, label); // Salto a la instrucción de inicio de la función
                        at1.code.addLabel(label); // Etiqueta de inicio de la función

    label_10:
    while (true) {
      instruccion(at1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tEXIT:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tSEMICOLON);
semantic.exitFunction(getToken(0));
                if (verbose) semantic.printSymbolTable(funcProcDecAt.id.image); // Impresión de la tabla de símbolos
                semantic.removeBlock(); // Eliminación del bloque actual
                at.code.addBlock(at1.code);
                at.code.addBlock(funcProcDecAt.code);
                at.code.addInst(PCodeInstruction.OpCode.CSF);
}

//lista_parametros: parametro_formal (<tSEMICOLON> parametro_formal)*
  static final public void lista_parametros(FuncProcDecAttrib funcProcDecAt) throws ParseException {
    parametro_formal(funcProcDecAt);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tSEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_11;
      }
      jj_consume_token(tSEMICOLON);
      parametro_formal(funcProcDecAt);
    }
}

//parametro_formal: lista_ids <tCOLON> <tREF>? tipo_variable
  static final public void parametro_formal(FuncProcDecAttrib funcProcDecAt) throws ParseException {ParVarAttrib parVarAt = new ParVarAttrib();
        TypeAttrib typeAt = new TypeAttrib();
    lista_ids(parVarAt.t);
    jj_consume_token(tCOLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tREF:{
      jj_consume_token(tREF);
parVarAt.paramClass = Symbol.ParameterClass.REF;
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
typeAt.t = null;
                typeAt.paramArray = parVarAt.paramArray;
                typeAt.paramClass = parVarAt.paramClass;
    tipo_variable(typeAt);
parVarAt.baseType = typeAt.type;

                for (Token id : parVarAt.t) {
                // Comprobar si hay algún parámetro con el mismo nombre (se hace tras declarar todos los parámetros)
                        System.out.println("ID: " + id.image);

                        if (parVarAt.baseType == Symbol.Types.ARRAY) { // Parámetros array
                                SymbolArray newArray = typeAt.paramArray.clone();
                                newArray.name = id.image;
                                funcProcDecAt.params.put(id, newArray); // Insertado de parámetro array en el diccionario de parámetros
                        } else { // Parámetros simples
                                switch (parVarAt.baseType) {
                                        // Insertado de parámetro (int|char|bool) en el diccionario de parámetros
                                        case INT:  funcProcDecAt.params.put(id, new  SymbolInt(id.image, parVarAt.paramClass)); break;
                                        case CHAR: funcProcDecAt.params.put(id, new SymbolChar(id.image, parVarAt.paramClass)); break;
                                        case BOOL: funcProcDecAt.params.put(id, new SymbolBool(id.image, parVarAt.paramClass)); break;
                                }
                        }
                }
                System.out.println("Lista de par\u00e1metros: " + funcProcDecAt.params);
}

/*------------------------------------------- INSTRUCCIONES -------------------------------------------*/

//instruccion: (inst_leer | <tSKIP_LINE> | inst_escribir | inst_escribir_linea | inst_invocacion_procedimiento_o_asignacion | inst_if | inst_while | <tNULL> | inst_return) <tSEMICOLON>
  static final public void instruccion(Attributes at) throws ParseException {Attributes at1 = new Attributes();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tGET:{
      inst_leer(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tSKIP_LINE:{
      jj_consume_token(tSKIP_LINE);
      skip_line(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tPUT:{
      inst_escribir(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tPUT_LINE:{
      inst_escribir_linea(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tID:{
      inst_invocacion_procedimiento_o_asignacion(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tIF:{
      inst_if(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tWHILE:{
      inst_while(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tRETURN:{
      inst_return(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tEXIT:{
      inst_exit(at1);
at.code.addBlock(at1.code);
      break;
      }
    case tNULL:{
      jj_consume_token(tNULL);
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(tSEMICOLON);
}

  static final public void skip_line(Attributes at) throws ParseException {long last_dir;
last_dir = semantic.getLastSymbolAddress();
                // System.out.println("Dirección de almacenamiento temporal: " + last_dir);
                String label = CGUtils.newLabel();
                at.code.addLabel(label);
                at.code.addInst(PCodeInstruction.OpCode.SRF, 0, (int) last_dir); // Dirección de almacén temporal (var local)
                at.code.addInst(PCodeInstruction.OpCode.RD, 0); // Leer de stdin y asignarlo a var_local
                at.code.addInst(PCodeInstruction.OpCode.SRF, 0, (int) last_dir);
                at.code.addInst(PCodeInstruction.OpCode.DRF); // Obtener valor que se acaba de escribir
                at.code.addInst(PCodeInstruction.OpCode.STC, 10);
                at.code.addInst(PCodeInstruction.OpCode.EQ); // Compararlo con el salto de línea
                at.code.addInst(PCodeInstruction.OpCode.JMF, label); // Repetir si no es así

}

//inst_leer: <tGET> <tLPAREN> inst_leer_elemento ( <tCOMMA> inst_leer_elemento )* <tRPAREN>
  static final public void inst_leer(Attributes at) throws ParseException {Attributes at1 = new Attributes();
    jj_consume_token(tGET);
    jj_consume_token(tLPAREN);
    inst_leer_elemento(at1);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_12;
      }
      jj_consume_token(tCOMMA);
      inst_leer_elemento(at1);
    }
    jj_consume_token(tRPAREN);
at.code.addBlock(at1.code);
}

//inst_leer_elemento: <tID> ( array_access )?
  static final public void inst_leer_elemento(Attributes at) throws ParseException {Attributes at1 = new Attributes();
        Token id;
        boolean access = false;
        /* Se deben leer variables asignables de tipo integer o character.
	   Solo son asignables las variables simples y los elementos de un array */

    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      array_access(at1);
access = true;
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      ;
    }
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // El error de símbolo no definido está en semantic.isSymbolDefined
                Symbol symbol = semantic.getSymbol(id);

                semantic.isProcedureOrFunction(id, symbol); // si es procedimiento o función, error

                /* Comprobaciones relacionadas con arrays:
		- Si es array: 
			- comprobar que se ha accedido a un elemento y no al array entero
			- comprobar que el tipo del array es INT o CHAR
		- Si no: que no se acceda a una variable simple, procedimiento o función como a un array
		*/
                semantic.readingArrayChecks(id, symbol, access);

                semantic.isBooleanBeingRead(id, symbol); // no se puede leer un booleano

                {
                        at.code.addBlock(at1.code);

                        // System.out.println("Leyendo " + id.image + "con nivel: " + symbol.nivel + " y dirección: " + symbol.dir);
                        at.code.addInst(PCodeInstruction.OpCode.SRF, symbol.nivel, (int) symbol.dir);
                        at.code.addInst(PCodeInstruction.OpCode.RD, symbol.type == Symbol.Types.CHAR ? 0 : 1);
                }
}

//array_access: <tLPAREN> expresion <tRPAREN>
  static final public void array_access(Attributes at) throws ParseException {ExpressionAttrib expAt = new ExpressionAttrib();
    jj_consume_token(tLPAREN);
    expresion(expAt);
semantic.indexIsInteger(getToken(0), expAt.type); // Comprobar que el índice es de tipo INT
                // No hace falta comprobar que el índice esté dentro del rango del array porque no se pide

    jj_consume_token(tRPAREN);
at.code.addBlock(expAt.code);
}

//inst_escribir: <tPUT> <tLPAREN> inst_escribir_elemento ( <tCOMMA> inst_escribir_elemento )* <tRPAREN>
  static final public void inst_escribir(Attributes at) throws ParseException {Attributes at1 = new Attributes();
    jj_consume_token(tPUT);
    jj_consume_token(tLPAREN);
    inst_escribir_elemento(at1);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        break label_13;
      }
      jj_consume_token(tCOMMA);
      inst_escribir_elemento(at1);
    }
    jj_consume_token(tRPAREN);
at.code.addBlock(at1.code);
}

//inst_escribir_linea: <tPUT_LINE> (<tLPAREN> inst_escribir_elemento (<tCOMMA> inst_escribir_elemento)* <tRPAREN>)?
  static final public void inst_escribir_linea(Attributes at) throws ParseException {Boolean hasString = false;
        Attributes at1 = new Attributes();
    jj_consume_token(tPUT_LINE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      inst_escribir_elemento(at1);
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tCOMMA:{
          ;
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          break label_14;
        }
        jj_consume_token(tCOMMA);
        inst_escribir_elemento(at1);
      }
      jj_consume_token(tRPAREN);
hasString = true;
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      ;
    }
if (hasString) {
                        at.code.addBlock(at1.code);
                }

                // Añadir siempre el salto de línea: CR + LF (asciis 13 y 10 respectivamente)
                at.code.addInst(PCodeInstruction.OpCode.STC, 13);
                at.code.addInst(PCodeInstruction.OpCode.WRT, 0);
                at.code.addInst(PCodeInstruction.OpCode.STC, 10);
                at.code.addInst(PCodeInstruction.OpCode.WRT, 0);
}

//inst_escribir_elemento: <tCONST_STRING> | expresion
  static final public void inst_escribir_elemento(Attributes at) throws ParseException {ExpressionAttrib expAt = new ExpressionAttrib();
        expAt.type = Symbol.Types.STRING; // default value
        Token value;
        // Se pueden escribir constantes string y expresiones de tipo integer, character y boolean, incluidos los elementos de un array

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tCONST_STRING:{
      value = jj_consume_token(tCONST_STRING);
// Iterar en el valor del string y escribir uno a uno los ascii de los caracteres
                        for (int i = 0; i < value.image.length(); i++) {
                                expAt.code.addInst(PCodeInstruction.OpCode.STC, value.image.charAt(i));
                                expAt.code.addInst(PCodeInstruction.OpCode.WRT, 0);
                        }
                        at.code.addBlock(expAt.code);
      break;
      }
    case tLPAREN:
    case tINT2CHAR:
    case tCHAR2INT:
    case tTRUE:
    case tFALSE:
    case tCONST_INT:
    case tCONST_CHAR:
    case tNOT:
    case tPLUS:
    case tMINUS:
    case tID:{
      expresion(expAt);
at.code.addBlock(expAt.code);
                at.code.addInst(PCodeInstruction.OpCode.WRT, expAt.type == Symbol.Types.CHAR ? 0 : 1);
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
switch (expAt.type) {
                        case INT:
                        case BOOL:
                        case CHAR:
                        case STRING: break;
                        case ARRAY: semantic.error(getToken(0), "No se puede escribir un array entero, pero s\u00ed componentes de array."); break;
                        default: semantic.error(getToken(0),
                                        "Solo se pueden escribir valores de tipo " + tokenImage[tINT] + ", " + tokenImage[tCHAR] + ", " + tokenImage[tBOOL] + " y " + tokenImage[tCONST_STRING] + ".");
                }
}

//inst_invocacion_procedimiento_o_asignacion: <tID> (array_access)? (<tASSIGN> expresion | <tLPAREN> lista_una_o_mas_exps <tRPAREN>)?
  static final public void inst_invocacion_procedimiento_o_asignacion(Attributes at) throws ParseException {Attributes at1 = new Attributes();
        ExpressionAttrib expAt = new ExpressionAttrib();
        Token id;
        boolean access = false;
    id = jj_consume_token(tID);
    if (jj_2_1(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLPAREN:{
        array_access(at1);
access = true;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(tASSIGN);
      expresion(expAt);
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // Si no está definido, no se puede comprobar nada más
                        Symbol symbol = semantic.getSymbol(id);

                        /* Comprobaciones relacionadas con arrays:
			- Si es array:
				- se debe acceder a un elemento (el array no es asignable pero sus elementos sí lo son)
				- comprobar que el tipo de la expresión coincide con el tipo base del array
			- Si no: no puede accederse a una variable no array
			*/
                        semantic.assigningArrayChecks(id, symbol, expAt.type, access);

                        /* Comprobaciones sobre los tipos de los asignables:
			- Si es un procedimiento o función, error
			- Asignable y expresión deben ser del mismo tipo
			*/
                        semantic.assignableTypeChecks(id, symbol, expAt.type); // Solamente son asignables las variables simples y los elementos de un array

                        {
                                int currentLevel = semantic.getCurrentLevel();
                                at.code.addInst(PCodeInstruction.OpCode.SRF, currentLevel - symbol.nivel, (int) symbol.dir);
                                at.code.addBlock(expAt.code);
                                at.code.addBlock(at1.code);
                                at.code.addInst(PCodeInstruction.OpCode.ASG);
                        }
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLPAREN:{
        jj_consume_token(tLPAREN);
        lista_una_o_mas_exps(id, at1);
        jj_consume_token(tRPAREN);
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // Si no está definido, no se puede comprobar nada más
                        Symbol symbol = semantic.getSymbol(id);

                        semantic.procedureChecks(id, symbol); // Comprobar que el símbolo es un procedimiento, y que no es el procedimiento principal

                        {
                                // apilar los parámetros
                                at.code.addBlock(expAt.code);
                                at.code.addBlock(at1.code);

                                // addOSFInst (int s, int l, String label) --> respetando 's' componentes del bloque actual, ocultando 'l' bloques de activación, comenzando la ejecución en 'label'
                                String label = semantic.getLabelFromSymbol(id);
                                at.code.addOSFInst((int) (semantic.getLastSymbolAddress()+1), symbol.nivel, label); // TODO: REVISAR PARÁMETROS DE OSF (creo que 's' y 'label' están ya bien)
                        }
    }
}

//inst_if: <tIF> expresion <tTHEN> instruccion+ (<tELSIF> expresion <tTHEN> instruccion+)* (<tELSE> instruccion+)? <tEND> <IF>
  static final public void inst_if(Attributes at) throws ParseException {ExpressionAttrib expAt = new ExpressionAttrib();
        ExpressionAttrib expAt1 = new ExpressionAttrib();
        Attributes at1 = new Attributes();
        Attributes at2 = new Attributes();
        Attributes at3 = new Attributes();
        Boolean hasElsif = false;
String label_elsif = CGUtils.newLabel();
                String label_end = CGUtils.newLabel();
                String label_else = CGUtils.newLabel();
    jj_consume_token(tIF);
    expresion(expAt);
semantic.ifChecks(getToken(0), expAt.type); // Comprobar que la guarda es de tipo BOOL

    jj_consume_token(tTHEN);
    label_15:
    while (true) {
      instruccion(at1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tEXIT:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        break label_15;
      }
    }
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tELSIF:{
        ;
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        break label_16;
      }
      jj_consume_token(tELSIF);
      expresion(expAt1);
hasElsif = true;
                semantic.ifChecks(getToken(0), expAt1.type); // Comprobar que la guarda es de tipo BOOL

      jj_consume_token(tTHEN);
      label_17:
      while (true) {
        instruccion(at2);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tWHILE:
        case tIF:
        case tRETURN:
        case tPUT:
        case tPUT_LINE:
        case tGET:
        case tSKIP_LINE:
        case tEXIT:
        case tNULL:
        case tID:{
          ;
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          break label_17;
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tELSE:{
      jj_consume_token(tELSE);
      label_18:
      while (true) {
        instruccion(at3);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tWHILE:
        case tIF:
        case tRETURN:
        case tPUT:
        case tPUT_LINE:
        case tGET:
        case tSKIP_LINE:
        case tEXIT:
        case tNULL:
        case tID:{
          ;
          break;
          }
        default:
          jj_la1[35] = jj_gen;
          break label_18;
        }
      }
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(tEND);
    jj_consume_token(tIF);
/* Backup de If-else funcional:
			at.code.addBlock(expAt.code); // If: Guarda 
			at.code.addInst(PCodeInstruction.OpCode.JMF, label_else); // Salto a Else si la guarda es falsa
			at.code.addBlock(at1.code);	// If: Instrucciones
			at.code.addInst(PCodeInstruction.OpCode.JMP, label_end); // Salto al final del if
			at.code.addLabel(label_else); // Else
			at.code.addBlock(at3.code); // Else: Instrucciones
			at.code.addLabel(label_end); // Fin del if
		*/

                // Elsif (1 nivel) funcional. TODO: hacer recursivo para más niveles
                at.code.addBlock(expAt.code); // If: Guarda 
                if (hasElsif) at.code.addInst(PCodeInstruction.OpCode.JMF, label_elsif); // Salto a Elsif si la guarda es falsa
                at.code.addBlock(at1.code);     // If: Instrucciones
                at.code.addInst(PCodeInstruction.OpCode.JMP, label_end); // Salto al final del if
                at.code.addLabel(label_elsif); // Elsif
                at.code.addBlock(expAt1.code); // Elsif: Guarda
                at.code.addInst(PCodeInstruction.OpCode.JMF, label_else); // Salto a Else si la guarda es falsa
                at.code.addBlock(at2.code); // Elsif: Instrucciones
                at.code.addInst(PCodeInstruction.OpCode.JMP, label_end); // Salto al final del if
                at.code.addLabel(label_else); // Else
                at.code.addBlock(at3.code); // Else: Instrucciones
                at.code.addLabel(label_end); // Fin del if

}

//inst_while: <tWHILE> expresion <tLOOP> instruccion+ <tENDLOOP>
  static final public void inst_while(Attributes at) throws ParseException {ExpressionAttrib expAt = new ExpressionAttrib();
        Attributes at1 = new Attributes();
        String label_init, label_end;
label_init = CGUtils.newLabel();
                label_end = CGUtils.newLabel();
                expAt.code.addLabel(label_init);
    jj_consume_token(tWHILE);
    expresion(expAt);
semantic.whileChecks(getToken(0), expAt.type); // Comprobar que la guarda es de tipo BOOL
                expAt.code.addInst(PCodeInstruction.OpCode.JMF, label_end); // Salto al final del bucle si la guarda es falsa

    jj_consume_token(tLOOP);
    label_19:
    while (true) {
      instruccion(at1);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tEXIT:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        break label_19;
      }
    }
at1.code.addInst(PCodeInstruction.OpCode.JMP, label_init);
    jj_consume_token(tEND);
    jj_consume_token(tLOOP);
at.code.addBlock(expAt.code);
                at.code.addBlock(at1.code);
                at.code.addLabel(label_end); // Fin del bucle

}

//inst_return: <tRETURN> expresion
  static final public void inst_return(Attributes at) throws ParseException {ExpressionAttrib expAt = new ExpressionAttrib();
        Token t;
    t = jj_consume_token(tRETURN);
    expresion(expAt);
semantic.inst_return(t, expAt.type);
                at.code.addBlock(expAt.code);
                at.code.addInst(PCodeInstruction.OpCode.CSF); // Añadida siempre tras un return

}

//inst_exit: <tEXIT>
  static final public void inst_exit(Attributes at) throws ParseException {
    jj_consume_token(tEXIT);
at.code.addInst(PCodeInstruction.OpCode.LVP);
}

/*--------------------------------------- EXPRESIONES ---------------------------------------*/

//expresion: relacion ( (<tAND> relacion)+ | (<tOR> relacion)+ )?
/** 🎃 REVISAR MAIL QUE MANDÓ (20/4) SOBRE FALLO EN ESTA PRODUCCIÓN
 * Params:
 * -param: != de null si es un parámetro de función/procedimiento, o bien una componente de un vector
 * -esAsignable: array de un único booleano para comprobar si la expresión es asignable. Debe ser un array
 * 				 para ser un elemento mutable y poder modificar su valor en las producciones que lo necesiten.
 */
  static final public void expresion(ExpressionAttrib expAt) throws ParseException {ExpressionAttrib expAt1 = new ExpressionAttrib();
        ExpressionAttrib expAt2 = new ExpressionAttrib();
        Symbol.Types type;
        boolean moreThanOne = false;
        String errorMsg = "Las relaciones de una expresi\u00f3n l\u00f3gica deben ser de tipo " + tokenImage[tBOOL] + ".";
        Token op = new Token();
    relacion(expAt1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tAND:
    case tOR:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tAND:{
        label_20:
        while (true) {
          op = jj_consume_token(tAND);
moreThanOne = true;
                                if (expAt1.type != Symbol.Types.BOOL)
                                        semantic.error(getToken(0), errorMsg);
          relacion(expAt2);
// Si hay más de una relación, deben ser todas BOOL
                                if (expAt2.type != Symbol.Types.BOOL)
                                        semantic.error(getToken(0), errorMsg);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case tAND:{
            ;
            break;
            }
          default:
            jj_la1[38] = jj_gen;
            break label_20;
          }
        }
        break;
        }
      case tOR:{
        label_21:
        while (true) {
          op = jj_consume_token(tOR);
moreThanOne = true;
                                if (expAt1.type != Symbol.Types.BOOL)
                                        semantic.error(getToken(0), errorMsg);
          relacion(expAt2);
// Si hay más de una relación, deben ser todas BOOL
                                if (expAt2.type != Symbol.Types.BOOL)
                                        semantic.error(getToken(0), errorMsg);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case tOR:{
            ;
            break;
            }
          default:
            jj_la1[39] = jj_gen;
            break label_21;
          }
        }
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      ;
    }
expAt.code.addBlock(expAt1.code); // Subir código hacia llamada superior

                if (moreThanOne && expAt1.esAsignable != null) expAt1.esAsignable = false; // Si hay más de una relación, la expresión no es asignable
                expAt.type = (moreThanOne) ? Symbol.Types.BOOL : expAt1.type;

                if (moreThanOne) {
                        // apilar operador lógico
                        switch (op.kind) {
                                case tAND: expAt.code.addInst(PCodeInstruction.OpCode.AND); break;
                                case tOR:  expAt.code.addInst(PCodeInstruction.OpCode.OR); break;
                        }
                }
}

//relacion: expresion_simple (operador_relacional expresion_simple)?
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public void relacion(ExpressionAttrib expAt) throws ParseException {ExpressionAttrib expAt1 = new ExpressionAttrib();
        ExpressionAttrib expAt2 = new ExpressionAttrib();
        Token op = new Token();
    expresion_simple(expAt1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tEQ:
    case tNEQ:
    case tLT:
    case tLE:
    case tGT:
    case tGE:{
      op = operador_relacional();
      expresion_simple(expAt2);
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
expAt.code.addBlock(expAt1.code); // Subir código hacia llamada superior

                // Puede haber una o dos expresiones, pero si hay dos, deben ser del mismo tipo
                if (expAt2.type != null) {
                        if (expAt1.esAsignable != null) expAt1.esAsignable = false; // Si hay dos expresiones, la expresión no es asignable
                        if (expAt1.type != expAt2.type)
                                semantic.error(getToken(0), "Las expresiones de una relaci\u00f3n deben ser del mismo tipo, se encontr\u00f3 " + expAt1.type + " y " + expAt2.type + ".");

                        expAt.type = Symbol.Types.BOOL; // Si hay dos expresiones, el resultado es booleano
                }
                // else: si hay solo una expresión, se devuelve su tipo
                else { expAt.type = expAt1.type; }

                // Si hay dos expresiones, entonces apilar el código de la segunda y el operador relacional
                if (expAt2.type != null) {
                        expAt.code.addBlock(expAt2.code);
                        // apilar operador relacional
                        switch (op.kind) {
                                case tEQ:  expAt.code.addInst(PCodeInstruction.OpCode.EQ); break;
                                case tLT:  expAt.code.addInst(PCodeInstruction.OpCode.LT); break;
                                case tGT:  expAt.code.addInst(PCodeInstruction.OpCode.GT); break;
                                case tLE:  expAt.code.addInst(PCodeInstruction.OpCode.LTE); break;
                                case tGE:  expAt.code.addInst(PCodeInstruction.OpCode.GTE); break;
                                case tNEQ: expAt.code.addInst(PCodeInstruction.OpCode.NEQ); break;
                        }
                }
}

//operador_relacional: (<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
  static final public Token operador_relacional() throws ParseException {Token op = new Token();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tEQ:{
      op = jj_consume_token(tEQ);
      break;
      }
    case tLT:{
      op = jj_consume_token(tLT);
      break;
      }
    case tGT:{
      op = jj_consume_token(tGT);
      break;
      }
    case tLE:{
      op = jj_consume_token(tLE);
      break;
      }
    case tGE:{
      op = jj_consume_token(tGE);
      break;
      }
    case tNEQ:{
      op = jj_consume_token(tNEQ);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return op;}
    throw new Error("Missing return statement in function");
}

//expresion_simple: ( <tPLUS> |	<tMINUS> )? termino ( ( <tPLUS> | <tMINUS> ) termino )*
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public void expresion_simple(ExpressionAttrib expAt) throws ParseException {boolean sign = false;
        ExpressionAttrib expAt1 = new ExpressionAttrib();
        ExpressionAttrib expAt2 = new ExpressionAttrib();
        Token op = new Token();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:{
        op = jj_consume_token(tPLUS);
        break;
        }
      case tMINUS:{
        op = jj_consume_token(tMINUS);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
sign = true;
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    termino(expAt1);
semantic.signInExpressionCheck(getToken(0), expAt1.type, sign); // Si hay signo, la expresión debe ser de tipo INT
                        if (op.kind == tMINUS) expAt1.code.addInst(PCodeInstruction.OpCode.NGI); // Si hay signo negativo, añadir instrucción de negación

    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:
      case tMINUS:{
        ;
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:{
        op = jj_consume_token(tPLUS);
        break;
        }
      case tMINUS:{
        op = jj_consume_token(tMINUS);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      termino(expAt2);
sign = true;
                        semantic.moreThanOneExpressionCheck(getToken(0), expAt2.type); // Si hay más de un término, deben ser todos INT

    }
expAt.code.addBlock(expAt1.code); // Subir código hacia llamada superior

                if (sign && expAt1.esAsignable != null) expAt1.esAsignable = false; // Si hay signo o más de un término, la expresión no es asignable
                expAt.type = (sign) ? Symbol.Types.INT : expAt1.type;

                // Si hay más de un término, añadir el código del segundo término y apilar el operador
                if (expAt2.type != null) {
                        expAt.code.addBlock(expAt2.code);
                        switch (op.kind) {
                                case tPLUS: expAt.code.addInst(PCodeInstruction.OpCode.PLUS); break;
                                case tMINUS: expAt.code.addInst(PCodeInstruction.OpCode.SBT); break;
                        }
                }
}

//termino: factor (operador_multiplicativo factor)*
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public void termino(ExpressionAttrib expAt) throws ParseException {boolean moreThanOne = false;
        ExpressionAttrib expAt1 = new ExpressionAttrib();
        ExpressionAttrib expAt2 = new ExpressionAttrib();
        Token op = new Token();
    factor(expAt1);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMULT:
      case tDIV:
      case tMOD:{
        ;
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        break label_23;
      }
      op = operador_multiplicativo();
moreThanOne = true;
                        semantic.multiplicativeFactorCheck(getToken(0), expAt1.type); // Los factores deben ser todos INT para poder operar con *, /, %

      factor(expAt2);
// Si hay más de un factor, deben ser todos INT
                        semantic.multiplicativeFactorCheck(getToken(0), expAt2.type); // Los factores deben ser todos INT para poder operar con *, /, %

    }
expAt.code.addBlock(expAt1.code); // Subir código hacia llamada superior

                if (moreThanOne && expAt1.esAsignable != null) expAt1.esAsignable = false; // Si hay más de un factor, la expresión no es asignable
                expAt.type = (moreThanOne) ? Symbol.Types.INT : expAt1.type;

                // Si hay más de un factor, añadir el código del segundo factor y apilar el operador
                if (expAt2.type != null) {
                        expAt.code.addBlock(expAt2.code);

                        switch (op.kind) {
                                case tMULT: expAt.code.addInst(PCodeInstruction.OpCode.TMS); break;
                                case tDIV:  expAt.code.addInst(PCodeInstruction.OpCode.DIV); break;
                                case tMOD:  expAt.code.addInst(PCodeInstruction.OpCode.MOD); break;
                        }
                }
}

//operador_multiplicativo: (<tMULT> | <tDIV> | <tMOD>)
  static final public Token operador_multiplicativo() throws ParseException {Token op = new Token();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMULT:{
      op = jj_consume_token(tMULT);
      break;
      }
    case tDIV:{
      op = jj_consume_token(tDIV);
      break;
      }
    case tMOD:{
      op = jj_consume_token(tMOD);
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return op;}
    throw new Error("Missing return statement in function");
}

//factor: (<tNOT>)? primario
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public void factor(ExpressionAttrib expAt) throws ParseException {// Symbol.Types type;
        boolean not = false;
        ExpressionAttrib expAt1 = new ExpressionAttrib();
        // expAt1.clone(expAt);

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tNOT:{
      jj_consume_token(tNOT);
not = true;
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    primario(expAt1);
expAt.code.addBlock(expAt1.code); // Subir código hacia llamada superior

                if (not) {
                        if (expAt1.esAsignable != null) expAt1.esAsignable = false;
                        semantic.notOperatorCheck(getToken(0), expAt1.type); // Operador 'not' solo se puede usar con variables de tipo BOOL 

                        expAt.code.addBlock(expAt1.code);
                        expAt.code.addInst(PCodeInstruction.OpCode.NGB);

                        expAt.type = Symbol.Types.BOOL;
                }
                expAt.type = expAt1.type;
}

//primario: <tLPAREN> expresion <tRPAREN> | <tINT2CHAR> <tLPAREN> expresion <tRPAREN> | <tCHAR2INT> <tLPAREN> expresion <tRPAREN> 
//			| <tID> <tLPAREN> lista_una_o_mas_exps <tRPAREN> | <tID> | <tCONST_INT> | <tCONST_CHAR> | <tTRUE> | <tFALSE>
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public void primario(ExpressionAttrib expAt) throws ParseException {ExpressionAttrib expAt1 = new ExpressionAttrib();
        Attributes at = new Attributes(); // TODO: revisar si hay que meter esto o el expAt1 en lista_una_o_mas_exps
        Symbol.Types type = Symbol.Types.UNDEFINED;
        Token id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      expresion(expAt1);
      jj_consume_token(tRPAREN);
expAt.code.addBlock(expAt1.code);
      break;
      }
    case tINT2CHAR:{
      jj_consume_token(tINT2CHAR);
      jj_consume_token(tLPAREN);
      expresion(expAt1);
      jj_consume_token(tRPAREN);
expAt.code.addBlock(expAt1.code);
                semantic.int2charCheck(getToken(0), expAt1.type); // La expresión debe ser de tipo INT
                expAt1.type = Symbol.Types.CHAR;
      break;
      }
    case tCHAR2INT:{
      jj_consume_token(tCHAR2INT);
      jj_consume_token(tLPAREN);
      expresion(expAt1);
      jj_consume_token(tRPAREN);
expAt.code.addBlock(expAt1.code);
                // La expresioón debe ser de tipo CHAR
                semantic.char2intCheck(getToken(0), expAt1.type); // La expresión debe ser de tipo CHAR
                expAt1.type = Symbol.Types.INT;
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      if (jj_2_2(2)) {
        id = jj_consume_token(tID);
        jj_consume_token(tLPAREN);
        lista_una_o_mas_exps(id, at);
        jj_consume_token(tRPAREN);
if (! semantic.isSymbolDefined(id)) expAt1.type = Symbol.Types.UNDEFINED;
                Symbol symbol = semantic.getSymbol(id);

                switch (symbol.type) {
                        // Si es una función, devolver su tipo retorno
                        case FUNCTION: expAt1.type = ((SymbolFunction) symbol).returnType; break;
                        // Checkear que no es procedimiento 
                        case PROCEDURE: semantic.procedureInPrimaryError(id, "funci\u00f3n"); break;
                        case ARRAY:
                                expAt1.type = ((SymbolArray) symbol).baseType; // Si es un array, devolver su tipo base
                                if (expAt.esAsignable != null) expAt.esAsignable = true;
                                id.clone(expAt.param);
                                break;
                        default: expAt1.type = symbol.type;
                }

                // apilar los parámetros y llamar a OSF
                expAt.code.addBlock(at.code);
                String label = semantic.getLabelFromSymbol(id);
                expAt.code.addOSFInst((int) (semantic.getLastSymbolAddress()+1), symbol.nivel, label); // TODO: REVISAR PARÁMETROS DE OSF (creo que 's' y 'label' están ya bien)

      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tID:{
          id = jj_consume_token(tID);
if (! semantic.isSymbolDefined(id)) expAt1.type = Symbol.Types.UNDEFINED;
                Symbol symbol = semantic.getSymbol(id);

                switch (symbol.type) {
                        case FUNCTION:
                                SymbolFunction function = (SymbolFunction) symbol;
                                semantic.functionParametersCheck(id, function); // Checkear que la función no tenga parámetros
                                expAt1.type = function.returnType;
                                String label = semantic.getLabelFromSymbol(id);
                                expAt.code.addOSFInst((int) (semantic.getLastSymbolAddress()+1), symbol.nivel, label); // TODO: REVISAR PARÁMETROS DE OSF (creo que 's' y 'label' están ya bien)
                                break;
                        // Checkear que no es procedimiento
                        case PROCEDURE: semantic.procedureInPrimaryError(id, "variable"); break;
                        // Si es un array y no se espera un parámetro, debe accederse a un elemento
                        case ARRAY: semantic.arrayAccessCheck(id, expAt.param);
                        default:
                                id.clone(expAt.param);
                                if (expAt.esAsignable != null) expAt.esAsignable = true;
                                expAt1.type = symbol.type;
                                int currentLevel = semantic.getCurrentLevel();
                                expAt.code.addInst(PCodeInstruction.OpCode.SRF, currentLevel - symbol.nivel, (int) symbol.dir);
                                expAt.code.addInst(PCodeInstruction.OpCode.DRF);
                }
          break;
          }
        case tCONST_INT:{
          jj_consume_token(tCONST_INT);
// guardar el valor del int y hacer: STC (ascii del int)
                        expAt1.type = Symbol.Types.INT;
                        expAt.code.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(getToken(0).image));
          break;
          }
        case tCONST_CHAR:{
          jj_consume_token(tCONST_CHAR);
// STC (ascii del char)
                        expAt1.type = Symbol.Types.CHAR;
                        expAt.code.addInst(PCodeInstruction.OpCode.STC, getToken(0).image.charAt(1));
          break;
          }
        case tTRUE:{
          jj_consume_token(tTRUE);
// STC 1
                        expAt1.type = Symbol.Types.BOOL;
                        expAt.code.addInst(PCodeInstruction.OpCode.STC, 1);
          break;
          }
        case tFALSE:{
          jj_consume_token(tFALSE);
// STC 0
                        expAt1.type = Symbol.Types.BOOL;
                        expAt.code.addInst(PCodeInstruction.OpCode.STC, 0);
          break;
          }
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
// No estoy seguro si los STC con 🎃 estarían bien, ya que no sé si en todos los casos
                // se debería de hacer el STC o solo en algunos casos determinados
                expAt.type = expAt1.type;
}

//lista_una_o_mas_exps: expresion() ( <tCOMMA> expresion() )*
/**
 * Params:
 * 	-id: Token de la función/procedimiento invocado, o del array accedido
 */
  static final public void lista_una_o_mas_exps(Token id, Attributes at) throws ParseException {// Se ejecuta en una invocación de función o procedimiento y en el acceso a un array en una expresión
        List<Symbol.Types> types = new ArrayList<>();
        Map<Token, Boolean> args = new LinkedHashMap<>();

        if (! semantic.isSymbolDefined(id)) return; // Si no se ha definido el símbolo (error semántico previo en primario)
        Symbol symbol = semantic.getSymbol(id);

        ExpressionAttrib expAt = new ExpressionAttrib();
expAt.esAsignable = false;
                expAt.param = new Token(0);
    expresion(expAt);
types.add(expAt.type);
                if (expAt.param.kind == 0) args.put(getToken(0), false);
                else                                       args.put(expAt.param, expAt.esAsignable);
                expAt.esAsignable = false;
                expAt.param = new Token(0);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        break label_24;
      }
      jj_consume_token(tCOMMA);
      expresion(expAt);
// Iterate over all the parameters
                        types.add(expAt.type);
                        if (expAt.param.kind == 0) args.put(getToken(0), false); // Si no se ha sobrescrito t, se añade el token actual
                        else                                       args.put(expAt.param, expAt.esAsignable);
                        expAt.esAsignable = false;
                        expAt.param = new Token(0);
    }
if (symbol.type == Symbol.Types.FUNCTION || symbol.type == Symbol.Types.PROCEDURE) {

                        // Recuperar lista parámetros del Token 'id' 
                        List<Symbol> parList = (symbol instanceof SymbolFunction) ? ((SymbolFunction) symbol).parList : ((SymbolProcedure) symbol).parList;

                        // Comprobar que el número de argumentos coincide con el número de parámetros
                        String msg = (symbol.type == Symbol.Types.FUNCTION) ? "de la funci\u00f3n" : "del procedimiento";
                        msg += " '" + id.image + "'";
                        if (semantic.checkNumberOfArguments(id, parList.size(), types.size(), msg)) {if ("" != null) return;} // Si no coinciden los parámetros, salir

                        // Comprobar que los tipos de los argumentos coinciden con los tipos de los parámetros
                        semantic.checkArgumentTypes(id, types, parList, args, msg);

                } else if (symbol.type == Symbol.Types.ARRAY) {
                        /*Comprobaciones sobre el array
			- El acceso a un array debe tener un único índice
			- El índice de un array debe ser de tipo integer
			*/
                        semantic.arrayInListOfExpressionCheck(id, types);
                } else { // Si id es un tipo simple, no puede accederse a un elemento
                        semantic.error(id, "No se puede acceder a un elemento del s\u00edmbolo '" + id.image + "' por ser de tipo " + symbol.type + " y no " + tokenImage[tARRAY] + ".");
                }
                at.code.addBlock(expAt.code);
}

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_3R_primario_1251_17_52()
 {
    if (jj_scan_token(tFALSE)) return true;
    return false;
  }

  static private boolean jj_3R_primario_1247_17_51()
 {
    if (jj_scan_token(tTRUE)) return true;
    return false;
  }

  static private boolean jj_3R_null_764_29_25()
 {
    if (jj_3R_array_access_663_9_26()) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_null_764_29_25()) jj_scanpos = xsp;
    if (jj_scan_token(tASSIGN)) return true;
    return false;
  }

  static private boolean jj_3R_primario_1243_17_50()
 {
    if (jj_scan_token(tCONST_CHAR)) return true;
    return false;
  }

  static private boolean jj_3R_primario_1175_37_45()
 {
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_941_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_957_19_39()
 {
    if (jj_scan_token(tOR)) return true;
    if (jj_3R_relacion_998_9_28()) return true;
    return false;
  }

  static private boolean jj_3R_primario_1239_17_49()
 {
    if (jj_scan_token(tCONST_INT)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_957_17_33()
 {
    Token xsp;
    if (jj_3R_expresion_957_19_39()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_957_19_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_lista_una_o_mas_exps_1291_11_54()
 {
    if (jj_scan_token(tCOMMA)) return true;
    if (jj_3R_expresion_941_9_27()) return true;
    return false;
  }

  static private boolean jj_3R_expresion_simple_1057_10_36()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    if (jj_3R_termino_1092_5_35()) return true;
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_lista_una_o_mas_exps_1279_9_53()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_factor_1145_11_42()
 {
    if (jj_scan_token(tNOT)) return true;
    return false;
  }

  static private boolean jj_3R_factor_1145_9_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_factor_1145_11_42()) jj_scanpos = xsp;
    if (jj_3R_primario_1175_9_43()) return true;
    return false;
  }

  static private boolean jj_3R_primario_1182_17_47()
 {
    if (jj_scan_token(tCHAR2INT)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_941_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_simple_1052_6_34()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    return false;
  }

  static private boolean jj_3R_termino_1093_11_41()
 {
    if (jj_3R_operador_multiplicativo_1129_9_44()) return true;
    if (jj_3R_factor_1145_9_40()) return true;
    return false;
  }

  static private boolean jj_3R_relacion_999_11_31()
 {
    if (jj_3R_operador_relacional_1036_9_37()) return true;
    if (jj_3R_expresion_simple_1052_5_30()) return true;
    return false;
  }

  static private boolean jj_3R_expresion_simple_1052_5_30()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_simple_1052_6_34()) jj_scanpos = xsp;
    if (jj_3R_termino_1092_5_35()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_simple_1057_10_36()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_expresion_943_19_38()
 {
    if (jj_scan_token(tAND)) return true;
    if (jj_3R_relacion_998_9_28()) return true;
    return false;
  }

  static private boolean jj_3R_expresion_943_17_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_943_17_32()) {
    jj_scanpos = xsp;
    if (jj_3R_expresion_957_17_33()) return true;
    }
    return false;
  }

  static private boolean jj_3R_expresion_943_17_32()
 {
    Token xsp;
    if (jj_3R_expresion_943_19_38()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_943_19_38()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_relacion_998_9_28()
 {
    if (jj_3R_expresion_simple_1052_5_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_relacion_999_11_31()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_lista_una_o_mas_exps_1279_9_53()
 {
    if (jj_3R_expresion_941_9_27()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_lista_una_o_mas_exps_1291_11_54()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_primario_1176_17_46()
 {
    if (jj_scan_token(tINT2CHAR)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_941_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_termino_1092_5_35()
 {
    if (jj_3R_factor_1145_9_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_termino_1093_11_41()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_array_access_663_9_26()
 {
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_941_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_operador_relacional_1036_9_37()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_operador_multiplicativo_1129_9_44()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_expresion_941_9_27()
 {
    if (jj_3R_relacion_998_9_28()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_943_17_29()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_primario_1175_9_43()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_primario_1175_37_45()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1176_17_46()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1182_17_47()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1213_17_48()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1239_17_49()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1243_17_50()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1247_17_51()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_1251_17_52()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_primario_1213_17_48()
 {
    if (jj_scan_token(tID)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public alike_4TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[54];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x6000000,0x6000000,0x80280000,0x400,0x1e000,0x0,0x0,0x0,0x0,0xe000,0x800,0x0,0x6000000,0x6000000,0x80280000,0x800,0x0,0x6000000,0x6000000,0x80280000,0x100,0x8000000,0x80280000,0x400,0x800,0x400,0x400,0x800,0x800,0x800,0x800,0x80280000,0x800000,0x80280000,0x80280000,0x1000000,0x80280000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x400,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x10000000,0x0,0x0,0x100000cf,0x0,0x0,0x1800000,0x1800000,0x1800000,0x1800000,0x0,0x0,0x10000000,0x0,0x0,0x100000cf,0x0,0x10000000,0x0,0x0,0x100000cf,0x0,0x0,0x100000cf,0x0,0x0,0x0,0x0,0x0,0x11811f30,0x0,0x0,0x100000cf,0x0,0x100000cf,0x100000cf,0x0,0x100000cf,0x4000,0x8000,0xc000,0xc000,0x7e0000,0x7e0000,0x1800000,0x1800000,0x1800000,0x1800000,0xe000000,0xe000000,0x10000,0x30,0x10000f00,0x0,};
	}
  static final private JJCalls[] jj_2_rtns = new JJCalls[2];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public alike_4(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public alike_4(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new alike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public alike_4(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new alike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new alike_4TokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public alike_4(alike_4TokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(alike_4TokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[62];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 54; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 62; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 2; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
