//*****************************************************************
// File:   alike.jj
// Author: Jes칰s L칩pez Ans칩n, 839922
// 		   Javier Sin Pelayo, 843442
// Date:   marzo 2024
// Coms:   compilar mediante "ant"
// Doc:    https://javacc.github.io/javacc/
//*****************************************************************

options {
	IGNORE_CASE = true;
	UNICODE_INPUT = true;
	// DEBUG_PARSER = true;
}

PARSER_BEGIN(alike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.SemanticFunctions.SemanticFunctions;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

public class alike {
	// Tabla de s칤mbolos global
	static SymbolTable st;
	static SemanticFunctions semantic;
	
	// Variable global necesaria para controlar la derivabilidad de la instrucci칩n 'return' 
	// dependiendo de si nos encontramos en una funci칩n o en un procedimiento. 
	static boolean inFunction = false;

   	public static void main(String[] args) {
	   	alike parser = null;

		st = new SymbolTable();
	   	semantic = new SemanticFunctions(st);
	   
	   	try {
			if(args.length == 0) {
				parser = new alike(System.in);
			}
			else {
				parser = new alike(new java.io.FileInputStream(args[0]));
			}
			//Programa es el s칤mbolo inicial de la gram치tica
			parser.Programa();
			
			if (!semantic.hayErrores())
				System.out.println("***** An치lisis terminado con 칠xito *****");
			else
				System.out.println("Detectados errores sem치nticos. No se genera c칩digo.");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("ERROR L칄XICO: " + e.getMessage());
		}
		catch (ParseException e) {
			System.err.println("----------------------------------------");
			System.err.println(e.getMessage());
		}
		catch (Exception e) {
			e.printStackTrace();
		}
   }
}


PARSER_END(alike)

//---------------------------------------------------------

TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) > 
|	< #DIGIT: ["0"-"9"] >

	// Separadores
|	< tSEMICOLON: ";" >
|	< tCOLON: ":" >
|	< tCOMMA: "," >

	// Delimitadores
|	< tLPAREN: "(" >
|	< tRPAREN: ")" >

	// Tipos de datos
|	< tINT: "integer" >
|	< tCHAR: "character" >
|	< tBOOL: "boolean" >

	// Palabras reservadas
|	< tWHILE: "while" > 
|   < tLOOP: "loop" >
|	< tIF: "if" >
|	< tTHEN: "then" >
|	< tELSIF: "elsif" >
|	< tELSE: "else" >

|   < tPROCEDURE: "procedure" >
|   < tFUNCTION: "function" >
|   < tREF: "ref" >
|   < tIS: "is" >
|   < tBEGIN: "begin" >
|   < tEND: "end" >
|	< tRETURN: "return" > 

|   < tARRAY: "array" >
| 	< tOF: "of" >
|	< tRANGE: ".." >

	// Funciones est치ndar
| 	< tPUT: "put" >
| 	< tPUT_LINE: "put_line" >
|	< tGET: "get" >
|	< tSKIP_LINE: "skip_line" >
|	< tINT2CHAR: "int2char" >
|	< tCHAR2INT: "char2int" >
|	< tEXIT: "exit" >
|	< tNULL: "null" >

	// Literales
| 	< tTRUE: "true" >
| 	< tFALSE: "false" >
| 	< tCONST_INT: (<DIGIT>)+ >
|	< tCONST_CHAR: "'"~[]"'" >
|	< tCONST_STRING: "\"" ((~["\""] | "\"\""))* "\"" > // Dos comillas dobles seguidas se consideran una comilla doble

	// Operadores
|	< tASSIGN: ":=" > 
|	< tAND: "and" >
|	< tOR: "or" >
|	< tNOT: "not" >
|	< tEQ: "=" >
|	< tNEQ: "/=" >
|	< tLT: "<" >
|	< tLE: "<=" >
|	< tGT: ">" >
|	< tGE: ">=" >
|	< tPLUS: "+" >
|	< tMINUS: "-" >
|	< tMULT: "*" >
|	< tDIV: "/" >
|	< tMOD: "mod" >

	// Otros
|	< tID: (<LETTER> | "_") (<LETTER> | <DIGIT> | "_")* >

}

SKIP : { 
	" " | "\t" | "\n" | "\r" 
	|  <COMMENT: "--" (~["\n", "\r"])*> 
}


//-------------------游녢游낖 Analizador sint치ctico 游녢游낖-------------------

//------------ S칤mbolo inicial de la gram치tica.
// Programa: <tPROCEDURE> <tID> <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instruccion* <tEND> <tSEMICOLON> <EOF>
void Programa() : 
{
	Token id;
}
{
	<tPROCEDURE> 
	id = <tID>
	{	// Procedimiento principal
		semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>()));
		st.insertBlock(); // Bloque 0
	}
	<tIS>
	( declaracion_var() )*
	( declaracion_procedimiento() | declaracion_funcion() )*
	<tBEGIN>
	(instruccion())+
	<tEND>
	<tSEMICOLON>
	{
		System.err.println(st.toString(id.image)); // Impresi칩n de la tabla de s칤mbolos
		st.removeBlock(); // Eliminaci칩n del bloque principal
	}

   < EOF >
}

//declaracion_var: lista_ids <tCOLON> tipo_variable <tSEMICOLON>
void declaracion_var() : 
{
	List<Token> t = new ArrayList<Token>();
}
{
	lista_ids(t)
	<tCOLON>
	tipo_variable(t, null, Symbol.ParameterClass.NONE)
	<tSEMICOLON> 
}

//lista_ids: <tID> (<tCOMMA> <tID>)*
void lista_ids(List<Token> tokens) :
{
	Token t;
}
{
	t = <tID> {tokens.add(t);}
	(<tCOMMA> 
	t = <tID> {tokens.add(t);} 
	)*
}

//tipo_variable: (tipo_variable_simple | tipo_variable_array)
Symbol.Types tipo_variable(List<Token> t, SymbolArray paramArray, Symbol.ParameterClass paramClass) : 
{
	Symbol.Types baseType = Symbol.Types.ARRAY; // Si no es tipo simple, es un array
}
{
	( baseType = tipo_variable_simple(t, null, paramClass) | tipo_variable_array(t, paramArray, paramClass) )
	{
		return baseType; // Si es un tipo simple, se devuelve el tipo de la variable
	}
}

//tipo_variable_array: <tARRAY> <tLPAREN> <tCONST_INT> <tRANGE> <tCONST_INT> <tRPAREN> <tOF> tipo_variable_simple
void tipo_variable_array(List<Token> t, SymbolArray paramArray, Symbol.ParameterClass paramClass) : 
{
	Token tMin, tMax;
	int min, max, minus1 = 1, minus2 = 1;
	Symbol.Types baseType;
	SymbolArray baseArray = null;
	boolean isParameter = (paramClass != Symbol.ParameterClass.NONE);
	boolean isDeclaration = !isParameter;
}
{
	<tARRAY> <tLPAREN> 
	(<tMINUS> {minus1 = -1;} | <tPLUS>)? tMin = <tCONST_INT> 
	<tRANGE> 
	(<tMINUS> {minus2 = -1;} | <tPLUS>)? tMax = <tCONST_INT> 
	<tRPAREN>
	{
		min = Integer.parseInt(tMin.image) * minus1;
		max = Integer.parseInt(tMax.image) * minus2;
		if (min > max) {
			semantic.error(getToken(0), "Los vectores deben tener un rango no vac칤o de enteros, se ha encontrado (" + min + ".." + max + ")");
		}
		if (isDeclaration) {
			baseArray = new SymbolArray("", min, max, Symbol.Types.UNDEFINED, paramClass);
			// baseArray se crea aqu칤 para que en tipo_variable_simple se pueda insertar en la 
			// tabla de s칤mbolos con los valores de min y max
		}
	}
	<tOF> baseType = tipo_variable_simple(t, baseArray, null)
	{
		if (isParameter){ // Par치metro ARRAY
			// paramArray se ha creado en parametro_formal para rellenarse aqu칤
			paramArray.minInd = min;
			paramArray.maxInd = max;
			paramArray.parClass = paramClass;
			paramArray.baseType = baseType;
		}
	}
}

//tipo_variable_simple: <tINT> | <tCHAR> | <tBOOL>
Symbol.Types tipo_variable_simple(List<Token> t, SymbolArray baseArray, Symbol.ParameterClass paramClass) : 
{
	Symbol.Types type = null;
	boolean isArray = (baseArray != null);
	// Si baseArray no es null, estamos en una declaraci칩n de array y 
	// contiene los valores de min, max y paramClass
}
{
	( <tINT>  { type = Symbol.Types.INT; }
	| <tCHAR> { type = Symbol.Types.CHAR; }
	| <tBOOL> { type = Symbol.Types.BOOL; }
	)
	{
		if (t == null) { // Par치metros
			// Si no hay tokens, devolver el tipo de la variable porque se est치n leyendo par치metros
			// y estos se insertan en st en declaracion_procedimiento y declaracion_funcion
			return type;
		}
		else if (isArray) { // Declaraci칩n de variables arrays
			baseArray.baseType = type;
			for (Token id : t) {
				SymbolArray newArray = baseArray.clone(); // Necesario para obtener un array nuevo con la info de 칤ndices
				newArray.name = id.image;
				semantic.insertSymbol(id, newArray);
			}
		} else { // Declaraci칩n de variables simples
			for (Token id : t) {
				switch (type) {
					// Se insertan en la 'st' aqu칤 pero SIN VALOR, por lo que har치 falta asign치rselo posteriormente
					case INT:  semantic.insertSymbol(id, new  SymbolInt(id.image, paramClass)); break;
					case CHAR: semantic.insertSymbol(id, new SymbolChar(id.image, paramClass)); break;
					case BOOL: semantic.insertSymbol(id, new SymbolBool(id.image, paramClass)); break;
				}
			}
		}
		return type;
	}
}

//declaracion_procedimiento: cabecera_procedimiento (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instrucciones <tEND>
void declaracion_procedimiento() : 
{
	Token id;
	Map <Token,Symbol> params = new HashMap<Token,Symbol>();
}
{
	<tPROCEDURE>
	id = <tID> // Puede NO tener par치metros
	( <tLPAREN> lista_parametros(params) <tRPAREN> )?
	{
		semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>(params.values())));
		st.insertBlock();
		// insertar params con los tokens en la tabla de s칤mbolos tras crear un nuevo bloque
		for (Map.Entry<Token, Symbol> entry : params.entrySet()) {
			semantic.insertSymbol(entry.getKey() ,entry.getValue());
		}
	}
	<tIS>
	(declaracion_var())*
	( declaracion_procedimiento() | declaracion_funcion() )*
	<tBEGIN>
	(instruccion())+
	<tEND>
	<tSEMICOLON>
	{
		System.err.println(st.toString(id.image)); // Impresi칩n de la tabla de s칤mbolos
		st.removeBlock(); // Eliminaci칩n del bloque actual
	}
}

//declaracion_funcion: <tFUNCTION> <tID> ( <tLPAREN> lista_parametros <tRPAREN> )? <tRETURN> tipo_variable <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instrucciones <tEND>
void declaracion_funcion() : 
{
	Token id;
	Symbol.Types returnType;
	Map <Token,Symbol> params = new HashMap<Token,Symbol>();
}
{
	<tFUNCTION>
	id = <tID>
	( <tLPAREN> lista_parametros(params) <tRPAREN> )? // Puede NO tener par치metros
	<tRETURN>
	returnType = tipo_variable_simple(null, null, Symbol.ParameterClass.NONE)
	{
		semantic.insertSymbol(id, new SymbolFunction(id.image,  new ArrayList<Symbol>(params.values()), returnType));
		st.insertBlock();
		// insertar params con los tokens en la tabla de s칤mbolos tras crear un nuevo bloque
		for (Map.Entry<Token, Symbol> entry : params.entrySet()) {
			semantic.insertSymbol(entry.getKey() ,entry.getValue());
		}
	}
	<tIS>
	(declaracion_var())*
	( declaracion_procedimiento() | declaracion_funcion() )*
	<tBEGIN>
		{semantic.enterFunction(id.image);}
	(instruccion())+
		{semantic.exitFunction();} // Se vuelve a establecer como false
	<tEND>
	<tSEMICOLON>
	{
		System.err.println(st.toString(id.image)); // Impresi칩n de la tabla de s칤mbolos
		st.removeBlock(); // Eliminaci칩n del bloque actual
	}
}


//lista_parametros: parametro_formal (<tSEMICOLON> parametro_formal)*
void lista_parametros(Map<Token,Symbol> params) : {}
{
	parametro_formal(params) 
	( <tSEMICOLON> parametro_formal(params) )*
}

//parametro_formal: lista_ids <tCOLON> <tREF>? tipo_variable
void parametro_formal(Map<Token,Symbol> params) : 
{
	List<Token> t = new ArrayList<Token>();
	SymbolArray paramArray = new SymbolArray(""); // Usado para par치metros array
	Symbol.Types baseType;
	Symbol.ParameterClass paramClass = Symbol.ParameterClass.VAL;
}
{
	lista_ids(t)
	<tCOLON>
	( <tREF> {paramClass = Symbol.ParameterClass.REF;} )?
	baseType = tipo_variable(null, paramArray, paramClass) 
	// Aqu칤 es el 칰nico lugar donde se utiliza paramArray ya que aqu칤 se leen par치metros
	// Funciona de manera que en tipo_variable_array al ver que paramClass no es NONE (es VAL o REF), se rellenan los datos de paramArray con: min, max y paramClass
	{
		for (Token id : t) {
			// Comprobar si hay alg칰n par치metro con el mismo nombre

			if (baseType == Symbol.Types.ARRAY) { // Par치metros array
				SymbolArray newArray = paramArray.clone();
				newArray.name = id.image;
				params.put(id, newArray);
			} else { // Par치metros simples
				switch (baseType) {
					case INT:  params.put(id, new  SymbolInt(id.image, paramClass)); break;
					case CHAR: params.put(id, new SymbolChar(id.image, paramClass)); break;
					case BOOL: params.put(id, new SymbolBool(id.image, paramClass)); break;
				}
			}
		}
	}
}


/*------------------------------------------- INSTRUCCIONES -------------------------------------------*/ 

//instruccion: (inst_leer | <tSKIP_LINE> | inst_escribir | inst_escribir_linea | inst_invocacion_procedimiento | inst_asignacion | inst_if | inst_while | inst_return | <tNULL>) <tSEMICOLON>
void instruccion(): {}
{
	(	inst_leer()
	|	<tSKIP_LINE> // Nunca recibe argumentos
	|   inst_escribir()
	|   inst_escribir_linea()
	|   inst_invocacion_procedimiento_o_asignacion()
	|   inst_if()
	|   inst_while()
	|   <tNULL>
	|   LOOKAHEAD({ semantic.inFunction() }) inst_return()
		// 'inst_return' solamente es derivable si estamos dentro de una funci칩n gracias al LOOKAHEAD sint치ctico.
	)
	<tSEMICOLON>
}

//inst_leer: <tGET> <tLPAREN> <tID> (array_access)? ( <tCOMMA> <tID> (array_access)? )* <tRPAREN>
void inst_leer() : {}
{
	<tGET> // Necesita par치metros
	<tLPAREN> 
	inst_leer_elemento()
	( <tCOMMA> inst_leer_elemento() )* 
	<tRPAREN>
}

void inst_leer_elemento() :
{
	Token id;
	boolean access = false;
	// Se deben leer variables asignables de tipo integer o character
	// Solo son asignables las variables simples y los elementos de un array
}
{
	id = <tID> ( array_access() {access = true;} )?
	{
		Symbol symbol = semantic.getSymbol(id); // El error de s칤mbolo no definido est치 en semantic.getSymbol
		if (symbol != null){
			// si es procedimiento o funci칩n, error
			if (symbol.type == Symbol.Types.PROCEDURE || symbol.type == Symbol.Types.FUNCTION) {
				semantic.error(id, "No se puede leer un procedimiento o funci칩n.");
			}

			if (symbol.type == Symbol.Types.ARRAY) {
				// si es array, comprobar que se ha accedido a un elemento y no al array entero
				if (!access) {
					semantic.error(id, "Se debe acceder a un elemento del array '" + id.image + "'.");
				}
				// si es array, comprobar que el tipo del array es INT o CHAR
				SymbolArray array = (SymbolArray) symbol;
				if (array.baseType != Symbol.Types.INT && array.baseType != Symbol.Types.CHAR) {
					semantic.error(id, "El array '" + id.image + "' debe ser de tipo " + tokenImage[tINT] + " o " + tokenImage[tCHAR] + ".");
				}
			}

			// comprobar que no se accede como a un array a una variable simple o procedimiento o func칩n
			if (symbol.type != Symbol.Types.ARRAY && access) {
				semantic.error(id, "No se puede acceder a un elemento del s칤mbolo '" + id.image + "' por ser de tipo " + symbol.type + ".");
			}

			// no puede ser boolean
			if (symbol.type == Symbol.Types.BOOL) {
				semantic.error(id, "No se puede leer una variable de tipo " + tokenImage[tBOOL] + ".");
			}
		}
	}
}

//array_access: <tLPAREN> expresion <tRPAREN>
void array_access() : 
{
	Symbol.Types type;
}
{
	<tLPAREN> 
	type = expresion() 
	{
		if (type != Symbol.Types.INT) { // Comprobar que el 칤ndice es de tipo INT
			semantic.error(getToken(0), "El 칤ndice de un array debe ser de tipo " + tokenImage[tINT] + ".");
		}
		// No hace falta comprobar que el 칤ndice est칠 dentro del rango del array porque no lo piden
	}
	<tRPAREN>
}

//inst_escribir: <tPUT> <tLPAREN> (<tCONST_STRING> | expresion) ( <tCOMMA> (<tCONST_STRING> | expresion) )* <tRPAREN>
void inst_escribir() : // 游꾺
{
	Token aux = null;
}
{
	<tPUT> // Necesita par치metros
	<tLPAREN> 
	(<tCONST_STRING> | expresion()) 
	( <tCOMMA> (<tCONST_STRING> | expresion()) )* 
	<tRPAREN>
}

//inst_escribir_linea: <tPUT_LINE> (<tLPAREN> expresion (<tCOMMA> expresion)* <tRPAREN>)?
void inst_escribir_linea() : {}
{// 游꾺
	<tPUT_LINE> // Puede NO tener par치metros
	(<tLPAREN> (<tCONST_STRING> | expresion())
	( <tCOMMA> (<tCONST_STRING> | expresion()) )* <tRPAREN>
	)?
}

//inst_invocacion_procedimiento_o_asignacion: <tID> ( inst_asignacion | inst_invocacion_procedimiento )
void inst_invocacion_procedimiento_o_asignacion() : {}// 游꾺
{
	<tID> 
	( // inst_asignacion() 
		LOOKAHEAD( (array_access())? <tASSIGN> ) // LOOKAHEAD sint치ctico para comprobar si es una asignaci칩n
	(array_access())?
	<tASSIGN>
	expresion()
	| // inst_invocacion_procedimiento()
	( <tLPAREN> expresion() ( <tCOMMA> expresion() )* <tRPAREN> )? )
}

//inst_if: <tIF> expresion <tTHEN> instruccion+ (<tELSIF> expresion <tTHEN> instruccion+)* (<tELSE> instruccion+)? <tENDIF>
void inst_if() : // 游꾺
{
	Symbol.Types type;
	String errorMsg = "La guarda de una sentencia " + tokenImage[tIF] + " o " +
			 tokenImage[tELSIF] + " debe ser de tipo " + tokenImage[tBOOL] + ".";
}
{
	<tIF>	  type = expresion() 
	{
		if (type != Symbol.Types.BOOL) { // Comprobar que la guarda es de tipo BOOL
			semantic.error(getToken(0), errorMsg);
		}
	}
	<tTHEN> ( instruccion() )+
	(<tELSIF> type = expresion()
	{
		if (type != Symbol.Types.BOOL) { // Comprobar que la guarda es de tipo BOOL
			semantic.error(getToken(0), errorMsg);
		}
	} <tTHEN> ( instruccion() )+ )* 
	(<tELSE> ( instruccion() )+ )? 
	<tEND> <tIF>
}

//inst_while: <tWHILE> expresion <tLOOP> instruccion+ <tENDLOOP>
void inst_while() : 
{
	Symbol.Types type;
}
{
	<tWHILE> type = expresion() 
	{
		if (type != Symbol.Types.BOOL) { // Comprobar que la guarda es de tipo BOOL
			semantic.error(getToken(0), "La guarda de un bucle " + tokenImage[tWHILE] + " debe ser de tipo " + tokenImage[tBOOL] + ".");
		}
	}
	<tLOOP> ( instruccion() )+ <tEND> <tLOOP>
}

//inst_return: <tRETURN> (expresion)?
void inst_return() : 
{
	Symbol.Types returnType;
}
{
	<tRETURN> returnType = expresion() 
	{
		// Comprobar que la expresi칩n de retorno es del mismo tipo que el tipo de retorno de la funci칩n
		SymbolFunction function = semantic.getCurrentFunctionSymbol();
		if (returnType != function.returnType) {
			String returnTypeStr, expectedTypeStr;
			switch (returnType) {
				case INT:  returnTypeStr = tokenImage[tINT]; break;
				case CHAR: returnTypeStr = tokenImage[tCHAR]; break;
				case BOOL: returnTypeStr = tokenImage[tBOOL]; break;
				default:   returnTypeStr = "indefinido"; break;
			}
			switch (function.returnType) {
				case INT:  expectedTypeStr = tokenImage[tINT]; break;
				case CHAR: expectedTypeStr = tokenImage[tCHAR]; break;
				case BOOL: expectedTypeStr = tokenImage[tBOOL]; break;
				default:   expectedTypeStr = "indefinido"; break;
			}
			semantic.error(getToken(0), "El tipo de retorno " + expectedTypeStr + " de la funci칩n '" + function.name +
					"' no coincide con el tipo " + returnTypeStr + " de la expresi칩n de retorno ");
		}
	}
}

/*--------------------------------------- EXPRESIONES ---------------------------------------*/ 

//expresion: relacion ((<tAND> | <tOR>) relacion)*
Symbol.Types expresion() : 
{
	ArrayList<Symbol.Types> relaciones = new ArrayList<>();
	Symbol.Types type;
}
{
	type = relacion() {relaciones.add(type);}
	((<tAND> | <tOR>) type = relacion() {relaciones.add(type);})*
	{
		// Si hay m치s de una relaci칩n, deben ser todas BOOL
		if (relaciones.size() > 1) {
			for (Symbol.Types token : relaciones) {
				if (token != Symbol.Types.BOOL) {
					semantic.error(getToken(0), "Las relaciones de una expresi칩n l칩gica deben ser de tipo " + tokenImage[tBOOL] + ".");
				}
			}
		}
		return relaciones.get(0);
	}
}

//relacion: expresion_simple (operador_relacional expresion_simple)?
Symbol.Types relacion() : 
{
	ArrayList<Symbol.Types> expresiones = new ArrayList<>();
	Symbol.Types type;
}
{
	type = expresion_simple() {expresiones.add(type);}
 	( operador_relacional() type = expresion_simple() {expresiones.add(type);} )?
	{
		// Puede haber una o dos expresiones, pero si hay dos, deben ser del mismo tipo
		if (expresiones.size() == 2) {
			if (expresiones.get(0) != expresiones.get(1))
				semantic.error(getToken(0), "Las expresiones de una relaci칩n deben ser del mismo tipo.");

			return Symbol.Types.BOOL; // Si hay dos expresiones, el resultado es booleano
		} 
		// else: si hay solo una expresi칩n, se devuelve su tipo
		return expresiones.get(0);
	}
}

//operador_relacional: (<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
void operador_relacional() : {}
{
	(<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
}

//expresion_simple: ( <tPLUS> |	<tMINUS> )? termino ( ( <tPLUS> | <tMINUS> ) termino )*
Symbol.Types expresion_simple() : 
{
	ArrayList<Symbol.Types> terminos = new ArrayList<>();
	Symbol.Types type;
	boolean sign1 = false;
}
{
     ( <tPLUS> {sign1 = true;}  | <tMINUS> {sign1 = true;}  )? type = termino() {terminos.add(type); }
	(( <tPLUS> | <tMINUS> )  type = termino() {terminos.add(type); } )*
	{
		// Si hay m치s de un t칠rmino, deben ser todos INT
		if (terminos.size() > 1) {
			for (Symbol.Types token : terminos) {
				if (token != Symbol.Types.INT) {
					semantic.error(getToken(0), 
							"Los t칠rminos de una suma o resta deben ser de tipo " + tokenImage[tINT] + ".");
				}
			}
		} else if (sign1 && (terminos.get(0) != Symbol.Types.INT)) {
			semantic.error(getToken(0), "Los signos " + tokenImage[tPLUS] + " y " + tokenImage[tMINUS] + 
					" solo se puede usar con variables de tipo " + tokenImage[tINT] + ".");
		}
		
		return terminos.get(0);
	}
}
                                                                                                                                                                         
//termino: factor (operador_multiplicativo factor)*
Symbol.Types termino() : 
{
	ArrayList<Symbol.Types> factores = new ArrayList<>();
	Symbol.Types type;
}
{
    type = factor() { factores.add(type); }
	( operador_multiplicativo() type = factor() { factores.add(type); } )*
	{ 
		// Si hay m치s de un factor, deben ser todos INT
		if (factores.size() > 1) {
			for (Symbol.Types token : factores) {
				if (token != Symbol.Types.INT) {
					semantic.error(getToken(0), 
							"Los factores de una multiplicaci칩n, divisi칩n y m칩dulo deben ser de tipo " + tokenImage[tINT] + ".");
				}
			}
		}
		return factores.get(0);
	}
}

//operador_multiplicativo: (<tMULT> | <tDIV> | <tMOD>)
void operador_multiplicativo() : {}
{
	(<tMULT> | <tDIV> | <tMOD>)
}

//factor: (<tNOT>)? primario
Symbol.Types factor() : 
{
	Symbol.Types type;
	boolean not = false;
}
{	// Falta tener en cuenta el not
	( <tNOT> {not = true;} )? type = primario() 
	{
		// Comprobar que el operador 'not' solo se puede usar con variables de tipo BOOL
		if (not && (type != Symbol.Types.BOOL)) {
			semantic.error(getToken(0), "El operador " + tokenImage[tNOT] + 
					" solo se puede usar con variables de tipo " + tokenImage[tBOOL] + ".");
		}
		return type;
	}
}

//primario: <tLPAREN> expresion <tRPAREN> | <tINT2CHAR> <tLPAREN> expresion <tRPAREN> | <tCHAR2INT> <tLPAREN> expresion <tRPAREN> 
//			| <tID> (<tLPAREN> lista_una_o_mas_exps <tRPAREN>)? | <tID> | <tCONST_INT> | <tCONST_CHAR> | <tTRUE> | <tFALSE>
Symbol.Types primario() : 
{
	Symbol.Types type;
	Token id;
}
{
	(	<tLPAREN> type = expresion() <tRPAREN> // Aqu칤 no hay que comprobar nada
	|	<tINT2CHAR> <tLPAREN> type = expresion() <tRPAREN>
	{
		// La expresi칩n debe ser de tipo INT
		if (type != Symbol.Types.INT) {
			semantic.error(getToken(0), "La expresi칩n debe ser de tipo " + tokenImage[tINT] + ".");
		}
		type = Symbol.Types.CHAR;
	}
	|	<tCHAR2INT> <tLPAREN> type = expresion() <tRPAREN>
	{ 
		// La expresio칩n debe ser de tipo CHAR
		if (type != Symbol.Types.CHAR) {
			semantic.error(getToken(0), "La expresi칩n debe ser de tipo " + tokenImage[tINT] + ".");
		}
		type = Symbol.Types.INT;
	}// 游꾺 SOLO QUEDA ESTA
	|	id = <tID> (<tLPAREN> lista_una_o_mas_exps(id) <tRPAREN>)? //invocar func. (con o sin par치metros) o comp. array 
	{
		// Comprobar el tipo de la variable id
		Symbol idSymbol = semantic.getSymbol(id);
		switch (idSymbol.type) {
			case ARRAY:     type = ((SymbolArray) idSymbol).baseType; break;
			case FUNCTION:  type = ((SymbolFunction) idSymbol).returnType; break;
			case PROCEDURE: semantic.error(id, "No se puede usar un procedimiento en una expresi칩n."); break;
			case UNDEFINED: semantic.error(id, "El s칤mbolo " + id.image + " no est치 definido."); break;
			default: type = idSymbol.type; break;
		}
		type = semantic.getSymbolType(id);
	}
	|	<tCONST_INT> {type = Symbol.Types.INT;}
	|	<tCONST_CHAR> {type = Symbol.Types.CHAR;}
	|	<tTRUE> {type = Symbol.Types.BOOL;}
	|	<tFALSE> {type = Symbol.Types.BOOL;}
	)
	{
		return type;
	}
}

//lista_una_o_mas_exps: expresion() ( <tCOMMA> expresion() )*
void lista_una_o_mas_exps(Token id) : 
{
	List<Symbol.Types> types = new ArrayList<>();
	Symbol.Types type;
}
{

	type = expresion() {types.add(type);}
	( <tCOMMA> type = expresion() {types.add(type);} )*
	{
		// comprobar que el n칰mero de par치metros coincide
		SymbolFunction function = (SymbolFunction) semantic.getSymbol(id);
		if (types.size() != function.parList.size()) {
			semantic.error(id, "El n칰mero de par치metros no coincide con la definici칩n de la funci칩n '" + id.image + "'.");
		}

		// comprobar que los tipos de los par치metros coinciden (un vector es del mismo tipo que otro si coincide su tipo base y rango)
		for (int i = 0; i < types.size(); i++) {
			Symbol expectedSymbol = function.parList.get(i);
			Symbol.Types actualSymbol = types.get(i);

			// USAR FUNCI칍N semantic.getArrayBaseType(Token id)

			// if (expectedSymbol instanceof SymbolArray && actualSymbol == Symbol.Types.ARRAY) {
			// 	SymbolArray expectedArray = (SymbolArray) expectedSymbol;
			
			// 	if (!expectedArray.baseType.equals(actualArray.baseType) || 
			// 		 expectedArray.minInd != actualArray.minInd || 
			// 		 expectedArray.maxInd != actualArray.maxInd) {
			// 		semantic.error(id, "El tipo del par치metro " + (i + 1) + " no coincide con la definici칩n de la funci칩n '" + id.image + "'.");
			// 	}
			// } else if (expectedSymbol.type != actualSymbol.type) {
			// 	semantic.error(id, "El tipo del par치metro " + (i + 1) + " no coincide con la definici칩n de la funci칩n '" + id.image + "'.");
			// }
		}

	}
}
