/* alike_4.java */
/* Generated By:JavaCC: Do not edit this line. alike_4.java */
package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.SemanticFunctions.SemanticFunctions;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.LinkedHashMap;

public class alike_4 implements alike_4Constants {

        static SymbolTable st; // Tabla de símbolos global
        static SemanticFunctions semantic; // Funciones semánticas

        static boolean verbose = false; // Flag modo verbose (impresión bloque cerrado tabla de símbolos)

        public static void main(String[] args) {
                alike_4 parser = null;

                // argumento verbose
                if (args.length > 1 && args[1].equals("-v")) {
                        verbose = true;
                }

                // creación de SemanticFuncions, donde se encapsula la lógica semántica junto a la tabla de símbolos
                st = new SymbolTable();
                semantic = new SemanticFunctions(st);
                String fileName = "";

                try {
                        if(args.length == 0) { // Si no se especifica fichero, se lee de la entrada estándar
                                parser = new alike_4(System.in);
                        }
                        else {
                                fileName = args[0] + ".al";
                                parser = new alike_4(new java.io.FileInputStream(fileName));
                        }
                        //Programa es el símbolo inicial de la gramática
                        parser.Programa();

                        if (!semantic.hayErrores())
                                System.out.println("***** An\u00e1lisis terminado con \u00e9xito *****");
                        else
                                if (semantic.getNumErrores() == 1) {
                                        System.out.println("Detectado 1 error sem\u00e1ntico. No se genera c\u00f3digo.");
                                } else {
                                        System.out.println("Detectados " + semantic.getNumErrores() + " errores sem\u00e1nticos. No se genera c\u00f3digo.");
                                }
                }
                catch (java.io.FileNotFoundException e) {
                        System.err.println ("Fichero " + fileName + " no encontrado.");
                }
                catch (TokenMgrError e) {
                        System.err.println("ERROR L\u00c9XICO: " + e.getMessage());
                }
                catch (ParseException e) {
                        System.err.println("----------------------------------------");
                        System.err.println(e.getMessage());
                }
                catch (Exception e) {
                        e.printStackTrace();
                }
   }

//------------ Símbolo inicial de la gramática.
// Programa: <tPROCEDURE> <tID> <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> instruccion+ <tEND> <tSEMICOLON> <EOF>
  static final public void Programa() throws ParseException {Token id;
    jj_consume_token(tPROCEDURE);
    id = jj_consume_token(tID);
// Procedimiento principal
                semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>()));
                semantic.setMainProcedureName(id.image);
    jj_consume_token(tIS);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      declaracion_var();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento();
        break;
        }
      case tFUNCTION:{
        declaracion_funcion();
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
    label_3:
    while (true) {
      instruccion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tSEMICOLON);
if (verbose) System.err.println(st.toString(id.image)); // Impresión de la tabla de símbolos

}

//declaracion_var: lista_ids <tCOLON> tipo_variable <tSEMICOLON>
  static final public void declaracion_var() throws ParseException {List<Token> t = new ArrayList<Token>();
    lista_ids(t);
    jj_consume_token(tCOLON);
    tipo_variable(t, null, Symbol.ParameterClass.NONE);
    jj_consume_token(tSEMICOLON);
}

//lista_ids: <tID> (<tCOMMA> <tID>)*
/**
 * Params:
 * 	-tokens: lista de tokens de la enumeración de los identificadores de las variables
 */
  static final public void lista_ids(List<Token> tokens) throws ParseException {Token t;
    t = jj_consume_token(tID);
tokens.add(t);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      jj_consume_token(tCOMMA);
      t = jj_consume_token(tID);
tokens.add(t);
    }
}

//tipo_variable: (tipo_variable_simple | tipo_variable_array)
/**
 * Params: 
 *	-t: lista de tokens de la enumeración de los identificadores de las variables
 *	-paramArray: creado y utilizado en la producción "parametro_formal" para rellenar los datos de un parámetro ARRAY
 *	-paramClass: valor != de NONE en caso de ser un parámetro
 */
  static final public Symbol.Types tipo_variable(List<Token> t, SymbolArray paramArray, Symbol.ParameterClass paramClass) throws ParseException {Symbol.Types baseType = Symbol.Types.ARRAY; // Si no es tipo simple, es un array

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tINT:
    case tCHAR:
    case tBOOL:{
      baseType = tipo_variable_simple(t, null, paramClass);
      break;
      }
    case tARRAY:{
      tipo_variable_array(t, paramArray, paramClass);
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return baseType;} // Si es un tipo simple, se devuelve el tipo de la variable

    throw new Error("Missing return statement in function");
}

//tipo_variable_array: <tARRAY> <tLPAREN> <tCONST_INT> <tRANGE> <tCONST_INT> <tRPAREN> <tOF> tipo_variable_simple
/**
 * Params:
 *	-t: lista de tokens de la enumeración de los identificadores de las variables
 *	-paramArray: necesario para heredar el valor de la producción previa "tipo_variable"
 *	-paramClass: valor != de NONE en caso de ser un parámetro (heredado de "tipo_variable")
 */
  static final public void tipo_variable_array(List<Token> t, SymbolArray paramArray, Symbol.ParameterClass paramClass) throws ParseException {Token tMin, tMax;
        int min, max, minus1 = 1, minus2 = 1;
        Symbol.Types baseType;
        SymbolArray baseArray = null;
        boolean isParameter = (paramClass != Symbol.ParameterClass.NONE);
        boolean isDeclaration = !isParameter;
    jj_consume_token(tARRAY);
    jj_consume_token(tLPAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMINUS:{
        jj_consume_token(tMINUS);
minus1 = -1;
        break;
        }
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    tMin = jj_consume_token(tCONST_INT);
    jj_consume_token(tRANGE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMINUS:{
        jj_consume_token(tMINUS);
minus2 = -1;
        break;
        }
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    tMax = jj_consume_token(tCONST_INT);
    jj_consume_token(tRPAREN);
min = Integer.parseInt(tMin.image) * minus1;
                max = Integer.parseInt(tMax.image) * minus2;
                semantic.emptyArrayRange(tMax, min, max); // Comprobar que el rango no es vacío (min > max)

                if (isDeclaration) {
                        baseArray = new SymbolArray("", min, max, Symbol.Types.UNDEFINED, paramClass);
                        /* baseArray se crea aquí para que en "tipo_variable_simple" se pueda
			   insertar en la tabla de símbolos con los valores de "min" y "max" */
                }
    jj_consume_token(tOF);
    baseType = tipo_variable_simple(t, baseArray, null);
if (isParameter){ // Parámetro ARRAY
                        // paramArray se ha creado en "parametro_formal" para rellenarse aquí
                        paramArray.minInd = min;
                        paramArray.maxInd = max;
                        paramArray.parClass = paramClass;
                        paramArray.baseType = baseType;
                }
}

//tipo_variable_simple: <tINT> | <tCHAR> | <tBOOL>
/*
 Params:
	-t: lista de tokens de la enumeración de los identificadores de las variables
	-baseArray: creado en "tipo_variable_array" para rellenar datos del array (índices y paramClass). 
				En esta producción se termina de rellenar (nombre) y se inserta en la tabla de símbolos.
	-paramClass: valor != de NONE en caso de ser un parámetro
 */
  static final public Symbol.Types tipo_variable_simple(List<Token> t, SymbolArray baseArray, Symbol.ParameterClass paramClass) throws ParseException {Symbol.Types type = null;
        boolean isArray = (baseArray != null);
        /* Si baseArray != de null, estamos en una declaración de
	   array y contiene los valores de min, max y paramClass */

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tINT:{
      jj_consume_token(tINT);
type = Symbol.Types.INT;
      break;
      }
    case tCHAR:{
      jj_consume_token(tCHAR);
type = Symbol.Types.CHAR;
      break;
      }
    case tBOOL:{
      jj_consume_token(tBOOL);
type = Symbol.Types.BOOL;
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (t == null) { // Parámetros
                        /* Si no hay tokens, devolver el tipo de la variable porque se están leyendo parámetros
			   y estos se insertan en st en declaracion_procedimiento y declaracion_funcion */
                        {if ("" != null) return type;}
                }
                else if (isArray) { // Declaración de variables arrays
                        baseArray.baseType = type;
                        for (Token id : t) {
                                SymbolArray newArray = baseArray.clone(); // Necesario para obtener un array nuevo con la info de índices y paramClass
                                newArray.name = id.image;
                                semantic.insertSymbol(id, newArray);
                        }
                } else { // Declaración de variables simples
                        for (Token id : t) {
                                switch (type) {
                                        case INT:  semantic.insertSymbol(id, new  SymbolInt(id.image, paramClass)); break;
                                        case CHAR: semantic.insertSymbol(id, new SymbolChar(id.image, paramClass)); break;
                                        case BOOL: semantic.insertSymbol(id, new SymbolBool(id.image, paramClass)); break;
                                }
                        }
                }
                {if ("" != null) return type;}
    throw new Error("Missing return statement in function");
}

//declaracion_procedimiento: <tPROCDURE> <tID> (<tLPAREN> lista_parametros <tRPAREN>)? <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
  static final public void declaracion_procedimiento() throws ParseException {Token id;
        Map <Token,Symbol> params = new LinkedHashMap<Token,Symbol>(); // Linked para mantener el orden de inserción

    jj_consume_token(tPROCEDURE);
    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      lista_parametros(params);
      jj_consume_token(tRPAREN);
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
semantic.insertSymbol(id, new SymbolProcedure(id.image, new ArrayList<Symbol>(params.values())));
                st.insertBlock();
                // insertar params con los tokens en la tabla de símbolos DESPUÉS de crear un nuevo bloque
                for (Map.Entry<Token, Symbol> entry : params.entrySet()) {
                        semantic.insertSymbol(entry.getKey(), entry.getValue());
                }
    jj_consume_token(tIS);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      declaracion_var();
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento();
        break;
        }
      case tFUNCTION:{
        declaracion_funcion();
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
    label_7:
    while (true) {
      instruccion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        break label_7;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tSEMICOLON);
if (verbose) System.err.println(st.toString(id.image)); // Impresión de la tabla de símbolos
                st.removeBlock(); // Eliminación del bloque actual

}

//declaracion_funcion: <tFUNCTION> <tID> ( <tLPAREN> lista_parametros <tRPAREN> )? <tRETURN> tipo_variable_simple <tIS> (declaracion_var)* (declaracion_procedimiento | declaracion_funcion)* <tBEGIN> (instruccion)+ <tEND> <tSEMICOLON>
  static final public void declaracion_funcion() throws ParseException {Token id;
        Symbol.Types returnType;
        SymbolFunction functionSymbol;
        Map <Token,Symbol> params = new LinkedHashMap<Token,Symbol>(); // Linked para mantener el orden de inserción

    jj_consume_token(tFUNCTION);
    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      lista_parametros(params);
      jj_consume_token(tRPAREN);
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(tRETURN);
    returnType = tipo_variable_simple(null, null, Symbol.ParameterClass.NONE);
functionSymbol = new SymbolFunction(id.image, new ArrayList<Symbol>(params.values()), returnType);
                semantic.insertSymbol(id, functionSymbol);
                st.insertBlock();
                // insertar params con los tokens en la tabla de símbolos DESPUÉS de crear un nuevo bloque
                for (Map.Entry<Token, Symbol> entry : params.entrySet()) {
                        semantic.insertSymbol(entry.getKey() ,entry.getValue());
                }
    jj_consume_token(tIS);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        break label_8;
      }
      declaracion_var();
    }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:
      case tFUNCTION:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPROCEDURE:{
        declaracion_procedimiento();
        break;
        }
      case tFUNCTION:{
        declaracion_funcion();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(tBEGIN);
semantic.enterFunction(functionSymbol);
    label_10:
    while (true) {
      instruccion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
    }
    jj_consume_token(tEND);
semantic.exitFunction(getToken(0));
                if (verbose) System.err.println(st.toString(id.image)); // Impresión de la tabla de símbolos
                st.removeBlock(); // Eliminación del bloque actual

    jj_consume_token(tSEMICOLON);
}

//lista_parametros: parametro_formal (<tSEMICOLON> parametro_formal)*
/**
 * Params:
 * 	-params: Diccionario de Token-Symbol de los parámetros
 */
  static final public void lista_parametros(Map<Token,Symbol> params) throws ParseException {
    parametro_formal(params);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tSEMICOLON:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_11;
      }
      jj_consume_token(tSEMICOLON);
      parametro_formal(params);
    }
}

//parametro_formal: lista_ids <tCOLON> <tREF>? tipo_variable
/**
 * Params:
 * 	-params: Diccionario de Token-Symbol de los parámetros
 */
  static final public void parametro_formal(Map<Token,Symbol> params) throws ParseException {List<Token> t = new ArrayList<Token>();
        SymbolArray paramArray = new SymbolArray(""); // Usado para parámetros array
        Symbol.Types baseType;
        Symbol.ParameterClass paramClass = Symbol.ParameterClass.VAL;
    lista_ids(t);
    jj_consume_token(tCOLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tREF:{
      jj_consume_token(tREF);
paramClass = Symbol.ParameterClass.REF;
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    baseType = tipo_variable(null, paramArray, paramClass);
for (Token id : t) {
                // Comprobar si hay algún parámetro con el mismo nombre (se hace tras declarar todos los parámetros)

                        if (baseType == Symbol.Types.ARRAY) { // Parámetros array
                                SymbolArray newArray = paramArray.clone();
                                newArray.name = id.image;
                                params.put(id, newArray); // Insertado de parámetro array en el diccionario de parámetros
                        } else { // Parámetros simples
                                switch (baseType) {
                                        // Insertado de parámetro (int|char|bool) en el diccionario de parámetros
                                        case INT:  params.put(id, new  SymbolInt(id.image, paramClass)); break;
                                        case CHAR: params.put(id, new SymbolChar(id.image, paramClass)); break;
                                        case BOOL: params.put(id, new SymbolBool(id.image, paramClass)); break;
                                }
                        }
                }
}

/*------------------------------------------- INSTRUCCIONES -------------------------------------------*/

//instruccion: (inst_leer | <tSKIP_LINE> | inst_escribir | inst_escribir_linea | inst_invocacion_procedimiento_o_asignacion | inst_if | inst_while | <tNULL> | inst_return) <tSEMICOLON>
  static final public void instruccion() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tGET:{
      inst_leer();
      break;
      }
    case tSKIP_LINE:{
      jj_consume_token(tSKIP_LINE);
      break;
      }
    case tPUT:{
      inst_escribir();
      break;
      }
    case tPUT_LINE:{
      inst_escribir_linea();
      break;
      }
    case tID:{
      inst_invocacion_procedimiento_o_asignacion();
      break;
      }
    case tIF:{
      inst_if();
      break;
      }
    case tWHILE:{
      inst_while();
      break;
      }
    case tNULL:{
      jj_consume_token(tNULL);
      break;
      }
    case tRETURN:{
      inst_return();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(tSEMICOLON);
}

//inst_leer: <tGET> <tLPAREN> inst_leer_elemento ( <tCOMMA> inst_leer_elemento )* <tRPAREN>
  static final public void inst_leer() throws ParseException {
    jj_consume_token(tGET);
    jj_consume_token(tLPAREN);
    inst_leer_elemento();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_12;
      }
      jj_consume_token(tCOMMA);
      inst_leer_elemento();
    }
    jj_consume_token(tRPAREN);
}

//inst_leer_elemento: <tID> ( array_access )?
  static final public void inst_leer_elemento() throws ParseException {Token id;
        boolean access = false;
        /* Se deben leer variables asignables de tipo integer o character.
	   Solo son asignables las variables simples y los elementos de un array */

    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      array_access();
access = true;
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      ;
    }
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // El error de símbolo no definido está en semantic.isSymbolDefined
                Symbol symbol = semantic.getSymbol(id);

                semantic.isProcedureOrFunction(id, symbol); // si es procedimiento o función, error

                /* Comprobaciones relacionadas con arrays:
		- Si es array: 
			- comprobar que se ha accedido a un elemento y no al array entero
			- comprobar que el tipo del array es INT o CHAR
		- Si no: que no se acceda a una variable simple, procedimiento o función como a un array
		*/
                semantic.readingArrayChecks(id, symbol, access);

                semantic.isBooleanBeingRead(id, symbol); // no se puede leer un booleano

}

//array_access: <tLPAREN> expresion <tRPAREN>
  static final public void array_access() throws ParseException {Symbol.Types type;
    jj_consume_token(tLPAREN);
    type = expresion(null, null);
semantic.indexIsInteger(getToken(0), type); // Comprobar que el índice es de tipo INT
                // No hace falta comprobar que el índice esté dentro del rango del array porque no se pide

    jj_consume_token(tRPAREN);
}

//inst_escribir: <tPUT> <tLPAREN> inst_escribir_elemento ( <tCOMMA> inst_escribir_elemento )* <tRPAREN>
  static final public void inst_escribir() throws ParseException {
    jj_consume_token(tPUT);
    jj_consume_token(tLPAREN);
    inst_escribir_elemento();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        break label_13;
      }
      jj_consume_token(tCOMMA);
      inst_escribir_elemento();
    }
    jj_consume_token(tRPAREN);
}

//inst_escribir_elemento: <tCONST_STRING> | expresion
  static final public void inst_escribir_elemento() throws ParseException {Symbol.Types type = Symbol.Types.STRING;
        // Se pueden escribir constantes string y expresiones de tipo integer, character y boolean, incluidos los elementos de un array

    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tCONST_STRING:{
      jj_consume_token(tCONST_STRING);
      break;
      }
    case tLPAREN:
    case tINT2CHAR:
    case tCHAR2INT:
    case tTRUE:
    case tFALSE:
    case tCONST_INT:
    case tCONST_CHAR:
    case tNOT:
    case tPLUS:
    case tMINUS:
    case tID:{
      type = expresion(null, null);
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
switch (type) {
                        case INT:
                        case BOOL:
                        case CHAR:
                        case STRING: break;
                        case ARRAY: semantic.error(getToken(0), "No se puede escribir un array entero, pero s\u00ed componentes de array."); break;
                        default: semantic.error(getToken(0),
                                        "Solo se pueden escribir valores de tipo " + tokenImage[tINT] + ", " + tokenImage[tCHAR] + ", " + tokenImage[tBOOL] + " y " + tokenImage[tCONST_STRING] + ".");
                }
}

//inst_escribir_linea: <tPUT_LINE> (<tLPAREN> inst_escribir_elemento (<tCOMMA> inst_escribir_elemento)* <tRPAREN>)?
  static final public void inst_escribir_linea() throws ParseException {
    jj_consume_token(tPUT_LINE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      inst_escribir_elemento();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tCOMMA:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_14;
        }
        jj_consume_token(tCOMMA);
        inst_escribir_elemento();
      }
      jj_consume_token(tRPAREN);
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      ;
    }
}

//inst_invocacion_procedimiento_o_asignacion: <tID> (array_access)? (<tASSIGN> expresion | <tLPAREN> lista_una_o_mas_exps <tRPAREN>)?
  static final public void inst_invocacion_procedimiento_o_asignacion() throws ParseException {Token id;
        Symbol.Types type;
        boolean access = false;
    id = jj_consume_token(tID);
    if (jj_2_1(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLPAREN:{
        array_access();
access = true;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(tASSIGN);
      type = expresion(null, null);
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // Si no está definido, no se puede comprobar nada más
                Symbol symbol = semantic.getSymbol(id);

                /* Comprobaciones relacionadas con arrays:
		- Si es array:
			- se debe acceder a un elemento (el array no es asignable pero sus elementos sí lo son)
			- comprobar que el tipo de la expresión coincide con el tipo base del array
		- Si no: no puede accederse a una variable no array
		*/
                semantic.assigningArrayChecks(id, symbol, type, access);

                /* Comprobaciones sobre los tipos de los asignables:
		- Si es un procedimiento o función, error
		- Asignable y expresión deben ser del mismo tipo
		*/
                semantic.assignableTypeChecks(id, symbol, type); // Solamente son asignables las variables simples y los elementos de un array

    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tLPAREN:{
        jj_consume_token(tLPAREN);
        lista_una_o_mas_exps(id);
        jj_consume_token(tRPAREN);
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        ;
      }
if (! semantic.isSymbolDefined(id)) {if ("" != null) return;} // Si no está definido, no se puede comprobar nada más
                Symbol symbol = semantic.getSymbol(id);

                semantic.procedureChecks(id, symbol); // Comprobar que el símbolo es un procedimiento, y que no es el procedimiento principal

    }
}

//inst_if: <tIF> expresion <tTHEN> instruccion+ (<tELSIF> expresion <tTHEN> instruccion+)* (<tELSE> instruccion+)? <tEND> <IF>
  static final public void inst_if() throws ParseException {Symbol.Types type;
        String errorMsg = "La guarda de una sentencia " + tokenImage[tIF] + " o " +
                        tokenImage[tELSIF] + " debe ser de tipo " + tokenImage[tBOOL] + ".";
    jj_consume_token(tIF);
    type = expresion(null, null);
semantic.ifChecks(getToken(0), type, errorMsg); // Comprobar que la guarda es de tipo BOOL

    jj_consume_token(tTHEN);
    label_15:
    while (true) {
      instruccion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        break label_15;
      }
    }
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tELSIF:{
        ;
        break;
        }
      default:
        jj_la1[33] = jj_gen;
        break label_16;
      }
      jj_consume_token(tELSIF);
      type = expresion(null, null);
semantic.ifChecks(getToken(0), type, errorMsg); // Comprobar que la guarda es de tipo BOOL

      jj_consume_token(tTHEN);
      label_17:
      while (true) {
        instruccion();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tWHILE:
        case tIF:
        case tRETURN:
        case tPUT:
        case tPUT_LINE:
        case tGET:
        case tSKIP_LINE:
        case tNULL:
        case tID:{
          ;
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          break label_17;
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tELSE:{
      jj_consume_token(tELSE);
      label_18:
      while (true) {
        instruccion();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tWHILE:
        case tIF:
        case tRETURN:
        case tPUT:
        case tPUT_LINE:
        case tGET:
        case tSKIP_LINE:
        case tNULL:
        case tID:{
          ;
          break;
          }
        default:
          jj_la1[35] = jj_gen;
          break label_18;
        }
      }
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(tEND);
    jj_consume_token(tIF);
}

//inst_while: <tWHILE> expresion <tLOOP> instruccion+ <tENDLOOP>
  static final public void inst_while() throws ParseException {Symbol.Types type;
    jj_consume_token(tWHILE);
    type = expresion(null, null);
semantic.whileChecks(getToken(0), type); // Comprobar que la guarda es de tipo BOOL

    jj_consume_token(tLOOP);
    label_19:
    while (true) {
      instruccion();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tWHILE:
      case tIF:
      case tRETURN:
      case tPUT:
      case tPUT_LINE:
      case tGET:
      case tSKIP_LINE:
      case tNULL:
      case tID:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        break label_19;
      }
    }
    jj_consume_token(tEND);
    jj_consume_token(tLOOP);
}

//inst_return: <tRETURN> expresion
  static final public void inst_return() throws ParseException {Symbol.Types returnType;
    jj_consume_token(tRETURN);
    returnType = expresion(null, null);
semantic.inst_return(getToken(0), returnType);
}

/*--------------------------------------- EXPRESIONES ---------------------------------------*/

//expresion: relacion ( (<tAND> relacion)+ | (<tOR> relacion)+ )?
/**
 * Params:
 * -param: != de null si es un parámetro de función/procedimiento, o bien una componente de un vector
 * -esAsignable: array de un único booleano para comprobar si la expresión es asignable. Debe ser un array
 * 				 para ser un elemento mutable y poder modificar su valor en las producciones que lo necesiten.
 */
  static final public Symbol.Types expresion(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type;
        boolean moreThanOne = false;
        String errorMsg = "Las relaciones de una expresi\u00f3n l\u00f3gica deben ser de tipo " + tokenImage[tBOOL] + ".";
    type = relacion(param, esAsignable);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tAND:
    case tOR:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tAND:{
        label_20:
        while (true) {
          jj_consume_token(tAND);
moreThanOne = true;
                        if (type != Symbol.Types.BOOL)
                                semantic.error(getToken(0), errorMsg);
          type = relacion(null, null);
// Si hay más de una relación, deben ser todas BOOL
                        if (type != Symbol.Types.BOOL)
                                semantic.error(getToken(0), errorMsg);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case tAND:{
            ;
            break;
            }
          default:
            jj_la1[38] = jj_gen;
            break label_20;
          }
        }
        break;
        }
      case tOR:{
        label_21:
        while (true) {
          jj_consume_token(tOR);
moreThanOne = true;
                        if (type != Symbol.Types.BOOL)
                                semantic.error(getToken(0), errorMsg);
          type = relacion(null, null);
// Si hay más de una relación, deben ser todas BOOL
                        if (type != Symbol.Types.BOOL)
                                semantic.error(getToken(0), errorMsg);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case tOR:{
            ;
            break;
            }
          default:
            jj_la1[39] = jj_gen;
            break label_21;
          }
        }
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[41] = jj_gen;
      ;
    }
if (moreThanOne && esAsignable != null) esAsignable[0] = false; // Si hay más de una relación, la expresión no es asignable
                {if ("" != null) return (moreThanOne) ? Symbol.Types.BOOL : type;}
    throw new Error("Missing return statement in function");
}

//relacion: expresion_simple (operador_relacional expresion_simple)?
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public Symbol.Types relacion(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type1, type2 = Symbol.Types.UNDEFINED;
    type1 = expresion_simple(param, esAsignable);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tEQ:
    case tNEQ:
    case tLT:
    case tLE:
    case tGT:
    case tGE:{
      operador_relacional();
      type2 = expresion_simple(null, null);
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
// Puede haber una o dos expresiones, pero si hay dos, deben ser del mismo tipo
                if (type2 != Symbol.Types.UNDEFINED) {
                        if (esAsignable != null) esAsignable[0] = false; // Si hay dos expresiones, la expresión no es asignable
                        if (type1 != type2)
                                semantic.error(getToken(0), "Las expresiones de una relaci\u00f3n deben ser del mismo tipo, se encontr\u00f3 " + type1 + " y " + type2 + ".");

                        {if ("" != null) return Symbol.Types.BOOL;} // Si hay dos expresiones, el resultado es booleano
                }
                // else: si hay solo una expresión, se devuelve su tipo
                {if ("" != null) return type1;}
    throw new Error("Missing return statement in function");
}

//operador_relacional: (<tEQ> | <tLT> | <tGT> | <tLE> | <tGE> | <tNEQ>)
  static final public void operador_relacional() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tEQ:{
      jj_consume_token(tEQ);
      break;
      }
    case tLT:{
      jj_consume_token(tLT);
      break;
      }
    case tGT:{
      jj_consume_token(tGT);
      break;
      }
    case tLE:{
      jj_consume_token(tLE);
      break;
      }
    case tGE:{
      jj_consume_token(tGE);
      break;
      }
    case tNEQ:{
      jj_consume_token(tNEQ);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

//expresion_simple: ( <tPLUS> |	<tMINUS> )? termino ( ( <tPLUS> | <tMINUS> ) termino )*
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public Symbol.Types expresion_simple(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type;
        boolean sign = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tPLUS:
    case tMINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      case tMINUS:{
        jj_consume_token(tMINUS);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
sign = true;
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    type = termino(param, esAsignable);
if (sign && (type != Symbol.Types.INT)) {
                        semantic.error(getToken(0), "Los signos " + tokenImage[tPLUS] + " y " + tokenImage[tMINUS] +
                                        " solo se puede usar con expresiones de tipo " + tokenImage[tINT] + ", se encontr\u00f3 " + type + ".");
                }
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:
      case tMINUS:{
        ;
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tPLUS:{
        jj_consume_token(tPLUS);
        break;
        }
      case tMINUS:{
        jj_consume_token(tMINUS);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      type = termino(null, null);
sign = true;
                // Si hay más de un término, deben ser todos INT
                if (type != Symbol.Types.INT) {
                        semantic.error(getToken(0),
                                "Los t\u00e9rminos de una suma o resta deben ser de tipo " + tokenImage[tINT] + ", se encontr\u00f3 " + type + ".");
                }
    }
if (sign && esAsignable != null) esAsignable[0] = false; // Si hay signo o más de un término, la expresión no es asignable
                {if ("" != null) return (sign) ? Symbol.Types.INT : type;}
    throw new Error("Missing return statement in function");
}

//termino: factor (operador_multiplicativo factor)*
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public Symbol.Types termino(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type;
        boolean moreThanOne = false;
    type = factor(param, esAsignable);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tMULT:
      case tDIV:
      case tMOD:{
        ;
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        break label_23;
      }
      operador_multiplicativo();
moreThanOne = true;
                        if (type != Symbol.Types.INT) {
                                semantic.error(getToken(0),
                                                "Los factores de una multiplicaci\u00f3n, divisi\u00f3n y m\u00f3dulo deben ser de tipo " + tokenImage[tINT] + ", se encontr\u00f3 " + type + ".");
                        }
      type = factor(null, null);
// Si hay más de un factor, deben ser todos INT
                        if (type != Symbol.Types.INT) {
                                semantic.error(getToken(0),
                                                "Los factores de una multiplicaci\u00f3n, divisi\u00f3n y m\u00f3dulo deben ser de tipo " + tokenImage[tINT] + ", se encontr\u00f3 " + type + ".");
                        }
    }
if (moreThanOne && esAsignable != null) esAsignable[0] = false; // Si hay más de un factor, la expresión no es asignable
                {if ("" != null) return (moreThanOne) ? Symbol.Types.INT : type;}
    throw new Error("Missing return statement in function");
}

//operador_multiplicativo: (<tMULT> | <tDIV> | <tMOD>)
  static final public void operador_multiplicativo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tMULT:{
      jj_consume_token(tMULT);
      break;
      }
    case tDIV:{
      jj_consume_token(tDIV);
      break;
      }
    case tMOD:{
      jj_consume_token(tMOD);
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

//factor: (<tNOT>)? primario
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public Symbol.Types factor(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type;
        boolean not = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tNOT:{
      jj_consume_token(tNOT);
not = true;
      break;
      }
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    type = primario(param, esAsignable);
// Comprobar que el operador 'not' solo se puede usar con variables de tipo BOOL
                if (not) {
                        if (esAsignable != null) esAsignable[0] = false;
                        if (type != Symbol.Types.BOOL) {
                                semantic.error(getToken(0), "El operador " + tokenImage[tNOT] +
                                                " solo se puede usar con variables de tipo " + tokenImage[tBOOL] + ".");
                        }
                        {if ("" != null) return Symbol.Types.BOOL;}
                }
                {if ("" != null) return type;}
    throw new Error("Missing return statement in function");
}

//primario: <tLPAREN> expresion <tRPAREN> | <tINT2CHAR> <tLPAREN> expresion <tRPAREN> | <tCHAR2INT> <tLPAREN> expresion <tRPAREN> 
//			| <tID> <tLPAREN> lista_una_o_mas_exps <tRPAREN> | <tID> | <tCONST_INT> | <tCONST_CHAR> | <tTRUE> | <tFALSE>
/**
 * Params: análogo a los de la producción "expresion"
 */
  static final public Symbol.Types primario(Token param, boolean[] esAsignable) throws ParseException {Symbol.Types type = Symbol.Types.UNDEFINED;
        Token id;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case tLPAREN:{
      jj_consume_token(tLPAREN);
      type = expresion(null, null);
      jj_consume_token(tRPAREN);
      break;
      }
    case tINT2CHAR:{
      jj_consume_token(tINT2CHAR);
      jj_consume_token(tLPAREN);
      type = expresion(null, null);
      jj_consume_token(tRPAREN);
// La expresión debe ser de tipo INT
                if (type != Symbol.Types.INT) semantic.error(getToken(0), "La expresi\u00f3n debe ser de tipo " + tokenImage[tINT] + ".");
                type = Symbol.Types.CHAR;
      break;
      }
    case tCHAR2INT:{
      jj_consume_token(tCHAR2INT);
      jj_consume_token(tLPAREN);
      type = expresion(null, null);
      jj_consume_token(tRPAREN);
// La expresioón debe ser de tipo CHAR
                if (type != Symbol.Types.CHAR) semantic.error(getToken(0), "La expresi\u00f3n debe ser de tipo " + tokenImage[tINT] + ".");
                type = Symbol.Types.INT;
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      if (jj_2_2(2)) {
        id = jj_consume_token(tID);
        jj_consume_token(tLPAREN);
        lista_una_o_mas_exps(id);
        jj_consume_token(tRPAREN);
if (! semantic.isSymbolDefined(id)) {if ("" != null) return Symbol.Types.UNDEFINED;}
                Symbol symbol = semantic.getSymbol(id);

                switch (symbol.type) {
                        // Si es una función, devolver su tipo retorno
                        case FUNCTION: type = ((SymbolFunction) symbol).returnType; break;
                        case PROCEDURE: // Checkear que no es procedimiento
                                semantic.error(id, "No se puede invocar un procedimiento en una expresi\u00f3n como a una funci\u00f3n.");
                                break;
                        case ARRAY:
                                type = ((SymbolArray) symbol).baseType; // Si es un array, devolver su tipo base
                                if (esAsignable != null) esAsignable[0] = true;
                                id.clone(param);
                                break;
                        default: type = symbol.type;
                }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case tID:{
          id = jj_consume_token(tID);
if (! semantic.isSymbolDefined(id)) {if ("" != null) return Symbol.Types.UNDEFINED;}
                Symbol symbol = semantic.getSymbol(id);

                switch (symbol.type) {
                        case FUNCTION: // Checkear que la función no tiene parámetros
                                SymbolFunction function = (SymbolFunction) symbol;
                                if (function.parList.size() > 0) {
                                        semantic.error(id, "La funci\u00f3n '" + id.image + "' debe invocarse con " + function.parList.size() + " argumentos.");
                                }
                                type = function.returnType;
                                break;
                        case PROCEDURE: // Checkear que no es procedimiento 
                                semantic.error(id, "No se puede invocar un procedimiento en una expresi\u00f3n como a una variable.");
                                break;
                        case ARRAY:
                                // Si es un array y no se espera un parámetro, debe accederse a un elemento
                                if (param == null) semantic.error(id, "En una expresi\u00f3n debe accederse a un elemento del array '" + id.image + "'.");
                        default:
                                id.clone(param);
                                if (esAsignable != null) esAsignable[0] = true;
                                type = symbol.type;
                }
          break;
          }
        case tCONST_INT:{
          jj_consume_token(tCONST_INT);
type = Symbol.Types.INT;
          break;
          }
        case tCONST_CHAR:{
          jj_consume_token(tCONST_CHAR);
type = Symbol.Types.CHAR;
          break;
          }
        case tTRUE:{
          jj_consume_token(tTRUE);
type = Symbol.Types.BOOL;
          break;
          }
        case tFALSE:{
          jj_consume_token(tFALSE);
type = Symbol.Types.BOOL;
          break;
          }
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return type;}
    throw new Error("Missing return statement in function");
}

//lista_una_o_mas_exps: expresion() ( <tCOMMA> expresion() )*
/**
 * Params:
 * 	-id: Token de la función/procedimiento invocado, o del array accedido
 */
  static final public void lista_una_o_mas_exps(Token id) throws ParseException {// Se ejecuta en una invocación de función o procedimiento y en el acceso a un array en una expresión
        List<Symbol.Types> types = new ArrayList<>();
        Map<Token, Boolean> args = new LinkedHashMap<>();
        boolean[] esAsignable = {false};

        Symbol.Types type;
        if (! semantic.isSymbolDefined(id)) return; // Si no se ha definido el símbolo (error semántico previo en primario)
        Symbol symbol = semantic.getSymbol(id);

        Token t = new Token(0);
    type = expresion(t, esAsignable);
types.add(type);
                if (t.kind == 0) args.put(getToken(0), false);
                else                     args.put(t, esAsignable[0]);
                esAsignable[0] = false;
                t = new Token(0);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case tCOMMA:{
        ;
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        break label_24;
      }
      jj_consume_token(tCOMMA);
      type = expresion(t, esAsignable);
// Iterate over all the parameters
                        types.add(type);
                        if (t.kind == 0) args.put(getToken(0), false); // Si no se ha sobrescrito t, se añade el token actual
                        else                     args.put(t, esAsignable[0]);
                        esAsignable[0] = false;
                        t = new Token(0);
    }
if (symbol.type == Symbol.Types.FUNCTION || symbol.type == Symbol.Types.PROCEDURE) {

                        // Recuperar lista parámetros del Token 'id' 
                        List<Symbol> parList = (symbol instanceof SymbolFunction) ? ((SymbolFunction) symbol).parList : ((SymbolProcedure) symbol).parList;

                        // Comprobar que el número de argumentos coincide con el número de parámetros
                        String msg = (symbol.type == Symbol.Types.FUNCTION) ? "de la funci\u00f3n" : "del procedimiento";
                        msg += " '" + id.image + "'";
                        if (types.size() != parList.size()) {
                                semantic.error(id, "El n\u00famero de argumentos no coincide con el n\u00famero de par\u00e1metros " + msg);
                                {if ("" != null) return;}
                        }
                        List<Token> tokenArgs = new ArrayList<>(args.keySet());
                        List<Boolean> assignables = new ArrayList<>(args.values());

                        // Comprobar que los tipos de los argumentos coinciden con los tipos de los parámetros
                        for (int i = 0; i < types.size(); i++) {
                                if (types.get(i) == Symbol.Types.UNDEFINED) continue; // Si hay un error en la expresión, no comprobar más
                                if (types.get(i) != parList.get(i).type) {
                                        semantic.error(id, "El tipo " + types.get(i) + " del argumento n\u00ba " + (i + 1) + " no coincide con el tipo " + parList.get(i).type + " del par\u00e1metro " + msg);
                                        continue;
                                }

                                Token arg = tokenArgs.get(i);

                                if (parList.get(i).type == Symbol.Types.ARRAY) {

                                        // Si el parámetro debe ser un array, da igual si es por valor o referencia ya que el argumento debe ser un array entero
                                        SymbolArray paramArray = (SymbolArray) parList.get(i);

                                        // Si el argumento es un array, comprobar que el tipo base y el rango de índices coinciden (del parámetro y argumento)
                                        SymbolArray argArray = (SymbolArray) semantic.getSymbol(arg);

                                        if (argArray.baseType != paramArray.baseType) {
                                                semantic.error(arg, "El tipo base del vector '" + arg + "' no coincide con el tipo base del par\u00e1metro " + (i + 1) + " " + msg);
                                        }
                                        if (argArray.minInd != paramArray.minInd || argArray.maxInd != paramArray.maxInd) {
                                                semantic.error(arg, "El rango de \u00edndices del vector '" + arg  + "' no coincide con el rango de \u00edndices del par\u00e1metro " + (i + 1) + " " + msg);
                                        }
                                } else {
                                        // Si el parámetro es simple y por valor, no hay que comprobar nada más
                                        // Si el parámetro es simple por referencia, además el argumento debe ser un asignable (id o componente de array del mismo tipo)
                                        if (parList.get(i).parClass == Symbol.ParameterClass.REF) {
                                                if (!assignables.get(i)) {
                                                        semantic.error(arg, "El argumento n\u00ba " + (i + 1) + " no es una variable asignable para el par\u00e1metro por referencia " + msg);
                                                }
                                        }
                                }
                        }
                } else if (symbol.type == Symbol.Types.ARRAY) {
                        SymbolArray array = (SymbolArray) symbol;
                        if (types.size() != 1) {
                                semantic.error(id, "El acceso a un array debe tener un \u00fanico \u00edndice.");
                        }
                        if (types.get(0) != Symbol.Types.INT) {
                                semantic.error(id, "El \u00edndice de un array debe ser de tipo " + tokenImage[tINT] + ".");
                        }
                } else { // Si id es un tipo simple, no puede accederse a un elemento
                        semantic.error(id, "No se puede acceder a un elemento del s\u00edmbolo '" + id.image + "' por ser de tipo " + symbol.type + " y no  " + tokenImage[tARRAY] + ".");
                }
}

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_3R_factor_834_11_42()
 {
    if (jj_scan_token(tNOT)) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_null_590_21_25()) jj_scanpos = xsp;
    if (jj_scan_token(tASSIGN)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_687_17_29()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_687_17_32()) {
    jj_scanpos = xsp;
    if (jj_3R_expresion_700_19_33()) return true;
    }
    return false;
  }

  static private boolean jj_3R_expresion_687_17_32()
 {
    Token xsp;
    if (jj_3R_expresion_687_18_38()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_687_18_38()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_primario_920_17_52()
 {
    if (jj_scan_token(tFALSE)) return true;
    return false;
  }

  static private boolean jj_3R_factor_834_9_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_factor_834_11_42()) jj_scanpos = xsp;
    if (jj_3R_primario_860_9_43()) return true;
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_lista_una_o_mas_exps_945_9_53()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_primario_919_17_51()
 {
    if (jj_scan_token(tTRUE)) return true;
    return false;
  }

  static private boolean jj_3R_primario_918_17_50()
 {
    if (jj_scan_token(tCONST_CHAR)) return true;
    return false;
  }

  static private boolean jj_3R_primario_917_17_49()
 {
    if (jj_scan_token(tCONST_INT)) return true;
    return false;
  }

  static private boolean jj_3R_primario_867_17_47()
 {
    if (jj_scan_token(tCHAR2INT)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_686_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_686_9_27()
 {
    if (jj_3R_relacion_729_9_28()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_687_17_29()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_relacion_730_11_31()
 {
    if (jj_3R_operador_relacional_748_9_37()) return true;
    if (jj_3R_expresion_simple_761_5_30()) return true;
    return false;
  }

  static private boolean jj_3R_relacion_729_9_28()
 {
    if (jj_3R_expresion_simple_761_5_30()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_relacion_730_11_31()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_primario_861_17_46()
 {
    if (jj_scan_token(tINT2CHAR)) return true;
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_686_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_operador_multiplicativo_821_9_44()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_expresion_simple_768_10_36()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    if (jj_3R_termino_794_5_35()) return true;
    return false;
  }

  static private boolean jj_3R_lista_una_o_mas_exps_953_11_54()
 {
    if (jj_scan_token(tCOMMA)) return true;
    if (jj_3R_expresion_686_9_27()) return true;
    return false;
  }

  static private boolean jj_3R_primario_860_9_43()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_primario_860_37_45()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_861_17_46()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_867_17_47()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_892_17_48()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_917_17_49()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_918_17_50()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_919_17_51()) {
    jj_scanpos = xsp;
    if (jj_3R_primario_920_17_52()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_array_access_530_9_26()
 {
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_686_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_primario_892_17_48()
 {
    if (jj_scan_token(tID)) return true;
    return false;
  }

  static private boolean jj_3R_expresion_700_20_39()
 {
    if (jj_scan_token(tOR)) return true;
    if (jj_3R_relacion_729_9_28()) return true;
    return false;
  }

  static private boolean jj_3R_expresion_simple_761_6_34()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) return true;
    }
    return false;
  }

  static private boolean jj_3R_lista_una_o_mas_exps_945_9_53()
 {
    if (jj_3R_expresion_686_9_27()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_lista_una_o_mas_exps_953_11_54()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_expresion_700_19_33()
 {
    Token xsp;
    if (jj_3R_expresion_700_20_39()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_700_20_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_expresion_simple_761_5_30()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_expresion_simple_761_6_34()) jj_scanpos = xsp;
    if (jj_3R_termino_794_5_35()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_expresion_simple_768_10_36()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_termino_795_11_41()
 {
    if (jj_3R_operador_multiplicativo_821_9_44()) return true;
    if (jj_3R_factor_834_9_40()) return true;
    return false;
  }

  static private boolean jj_3R_operador_relacional_748_9_37()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_primario_860_37_45()
 {
    if (jj_scan_token(tLPAREN)) return true;
    if (jj_3R_expresion_686_9_27()) return true;
    if (jj_scan_token(tRPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_null_590_21_25()
 {
    if (jj_3R_array_access_530_9_26()) return true;
    return false;
  }

  static private boolean jj_3R_expresion_687_18_38()
 {
    if (jj_scan_token(tAND)) return true;
    if (jj_3R_relacion_729_9_28()) return true;
    return false;
  }

  static private boolean jj_3R_termino_794_5_35()
 {
    if (jj_3R_factor_834_9_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_termino_795_11_41()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public alike_4TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[54];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x6000000,0x6000000,0x80280000,0x400,0x1e000,0x0,0x0,0x0,0x0,0xe000,0x800,0x0,0x6000000,0x6000000,0x80280000,0x800,0x0,0x6000000,0x6000000,0x80280000,0x100,0x8000000,0x80280000,0x400,0x800,0x400,0x800,0x400,0x800,0x800,0x800,0x80280000,0x800000,0x80280000,0x80280000,0x1000000,0x80280000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x400,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x10000000,0x0,0x0,0x1000008f,0x0,0x0,0x1800000,0x1800000,0x1800000,0x1800000,0x0,0x0,0x10000000,0x0,0x0,0x1000008f,0x0,0x10000000,0x0,0x0,0x1000008f,0x0,0x0,0x1000008f,0x0,0x0,0x0,0x11811f30,0x0,0x0,0x0,0x0,0x1000008f,0x0,0x1000008f,0x1000008f,0x0,0x1000008f,0x4000,0x8000,0xc000,0xc000,0x7e0000,0x7e0000,0x1800000,0x1800000,0x1800000,0x1800000,0xe000000,0xe000000,0x10000,0x30,0x10000f00,0x0,};
	}
  static final private JJCalls[] jj_2_rtns = new JJCalls[2];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public alike_4(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public alike_4(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new alike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public alike_4(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new alike_4TokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new alike_4TokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public alike_4(alike_4TokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(alike_4TokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 54; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[62];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 54; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 62; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 2; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
